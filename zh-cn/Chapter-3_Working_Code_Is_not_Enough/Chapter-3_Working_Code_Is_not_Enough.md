处理编程任务时采用的思维方式，是良好软件设计的重要元素。许多组织鼓励战术思维，关注于让特性尽可能快的运行起来。然而，如果想要得到一个好的设计，必须采用更加战略的方式，投入时间来产生整洁设计，修复问题。本章讨论为什么战略方法能够产生更好的设计，以及为什么长期来看，战略方法要比战术方法更节省成本。

### 3.1 战术编程

多数编程者进行软件开发时所采用的思维，我称为战术编程思维。在战术方法中，主要关注于让某些东西运行起来，比如一个新的特性，或一个漏洞修复。第一眼看到这个，似乎是合情合理的，还有什么比编写能运行的代码更重要呢？然而，战术编程却几乎不可能产生好的软件设计。

战术编程的问题，在于它是短视的。如果采用战术编程，就会尝试尽快完成任务。或许你有一个强制的截止时间。最终，为未来作计划的优先级将会很低。你不会花费很多时间来寻找最好的设计，只想让某些东西快点运行起来。你告诉自己，如果能让当前任务更快完成，那增加一点复杂度，或引入一两个临时方案也是可以接受的。

这就是系统变得更加复杂的原因。正如前面章节所探讨的，复杂度是递增的。并不是某个特定的事物让系统变得复杂，而是数十上百的小事物累积而成。如果采用战术编程，每个编程任务都会增加一点复杂度。为了尽快完成当前任务，每个任务看起来都有合情合理的理由。然而，复杂度将会快速累积，如果每个人都战术编程则更是如此。

不久之后，某些复杂度将会开始引发问题，你开始希望如果早期没有采用这些取巧方式该多好。但你仍会告诉自己，让下一个新特性运行起来，比重构现存代码更重要。重构长期来看或许有所帮助，但它肯定会减缓当前任务。所以，你寻找快速布丁，来解决遇到的任何问题。这只会更加更多的复杂度，会需要更多的补丁。不久代码就会非常混乱，到目前为止，事情已经非常糟糕，这将需要花费几个月的时间，来对其进行整理。你的日程安排不可能容忍这种延迟，修复一两个问题，似乎并不会有什么不同，所以你会继续进行战术编程。

如果已经在某个大型软件项目上工作了很久，我想你可能已经在工作中见识过了战术编程，也体会过了它带来的问题。一旦开始选择了战术方式，将很难改变。

几乎每个软件开发组织，都至少有一个这样的开发者，他将战术编程发挥到了极致：战术龙卷风。战术龙卷风是指这样的一些开发者，他们快速生产代码，且远远快于其它人，而代码几乎都是战术风格。当他们实现一个敏捷特性时，没有任何人能比战术龙卷风更快完成。在某些组织，管理者认为战术龙卷风就是英雄。然而，战术龙卷风会留下一连串的破坏。他们很少被某些工程师认为是英雄，因为这些工程师后续将必须在他的代码上工作。通常，其它工程师比如清理战术龙卷风留下的混乱，从而让这些工程师（真正的英雄）的进度更慢于战术龙卷风。

### 3.2 战略设计

成为一名优秀软件设计师的第一步，就是认识到：**仅让代码能工作是不够的**。为了更快完成当前工作，而引入非必要的复杂度是不可接受的。软件的长期结构才是最重要的事。任何系统中的大部分代码，都是由现有代码而扩展，所以作为开发者，最重要的工作就是使这些未来的扩展更便捷。因此，尽管代码必须能运行，但不应将 “能工作的代码” 作为主要目标。主要目标必须是创造出伟大的设计，并且它也刚好有效。这就是战略编程。

战略编程需要投资思维。必须投入时间来优化系统设计，而不是采取捷径快速完成当前项目。这些投入可能会在短期内稍微减缓进度，但长期来看，它们将会加快进度，正如图 3.1 所示。

有些投入是主动的。举个例子，花费额外的一点时间，来寻找每个新类的简单设计，这是很有价值的，与其实现脑海中出现的第一个想法，不如多尝试一些备选设计，然后选择最简洁的那个。设想一些未来系统可能发生变动的方式，确保你的设计能够轻松适配。编写好的注释是另一个主动投入的例子。

另一些投入是被动的。无论之前投入了多少，设计决策不可避免的会有错误。随着时间的流逝，这些错误可能会逐渐明显。当发现这些设计问题时，不要忽略它，或只给它打个补丁，多花一些额外的时间来修复它。如果采用战略编程，将可以不断为系统增加小的优化。这也战术编程刚好相反，那里不断增加的是复杂度，而这些复杂度会在未来带来问题。

### 3.3 投入多少？

那么，投入多少是合适的呢？大量的前期投入（比如尝试设计整个系统）并不高效。这是瀑布开发的方式，我们知道这没什么作用。最佳的设计会随着对系统的了解，逐渐浮现。因此，最好是在持续投入的基础上，进行大量的小规模投入。我建议投入 10%-20% 的开发时间。这样的时间占比足够小，不会对日程安排产生明显影响，但又足够大，能够随时间的发展，而产生明显的收益。相比于纯战术编程的方式，基于战略方式开发的项目，初始阶段会因此而多出 10%-20% 的耗时。这部分额外的时间，将会带来更好的软件设计，并使你在几个月内感受到收益。用不了多久，你的开发速度就会比战术编程快 10%-20%。到了这个阶段，你将无需再进行额外投入，过去投入节省的时间，将能够覆盖未来投入的成本。你将很快收回最初的投入成本。图 3.1 说明了这种现象。

图 3.1：开始时，战术编程的进度会比战略编程略快。然而，战术编程下的复杂度累积越来越快，降低了生产力。随着时间的发展，战略编程取得了更好的进展。注意：该图的目的是仅作定性分析，我没有对曲线的精确数据有任何测量。

相反，如果采用战术编程，首个项目的完成时间会快 10%-20%，但随着时间的发展，开发速度将由于复杂度的累积而下降。用不了多久，编程进度就至少会慢 10%-20%。你很快就会归还开始时节省的时间，在系统剩余的生命周期里，你的开发速度都会慢于采用战略编程的情况。如果你还没有在这样糟糕的代码库中工作过，可以问下那些工作过的人，他们将会告诉你，糟糕的代码质量，至少会减慢 20% 的开发速度。