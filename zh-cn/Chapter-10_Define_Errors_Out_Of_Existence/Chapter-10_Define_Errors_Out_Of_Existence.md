## Define Errors Out Of Existence

异常处理是软件系统复杂度的最大来源之一。对于那些处理特殊情况的代码来说，其编写难度本来就高于那些处理正常情况的代码，而开发者却经常在没有考虑如何处理这些异常的情况下去定义它们。这一章将会讨论为什么异常会对复杂度产生不成比例的影响，然后将展示如何简化异常的处理逻辑。本章关键的结论在于减少必须处理的异常发生地点的数量，在大部分情况下，可以通过修改操作语意的方式，使得正常处理行为可以兼容所有的场景，此时这里将没有异常的情况需要报告（正如本章的标题所述）。

### 10.1 为什么异常会增加复杂度

我使用 “异常” 一次来代指那些特殊的情况，这些情况改动了系统的正常执行流程。许多编程语言都提供了正式的异常处理机制，这使得异常能够被低层的代码抛出，然后被封闭的代码所捕获。但是异常也可能发生在一些没有使用正式异常报告机制的场景下，比如当一个方法返回了一个特殊值，该值表示其方法没有完成其正常处理逻辑。所有形式的异常都会增加复杂度。

某一段代码可能会通过以下几种不同的方式遇到异常：

* 调用者可能提供了错误的参数或错误的配置；
* 一个被调用的方法可能无法完成其被请求的操作。例如，一个 I/O 操作可能会失败，一个必要的资源可能不可用；
* 在分布式系统下，网络包可能会丢失或延迟，服务端可能无法及时的响应，或者对端可能以一种非预期的方式发起请求；
* 代码可能会存在漏洞，内部的不一致，或者遇到一些未提前预备处理方案的场景；

大型系统需要处理很多的异常情况，当其是分布式系统或需要具备容错能力时更是如此。异常处理可以解析系统中所有代码的重要部分。

异常处理代码的编写难度本身就高于正常逻辑代码的编写。一个异常阻断了代码的正常执行流程，这通常意味着一些工作没有按预期所执行。当异常发生时，程序员可以通过两种方式来进行处理，但两种方式都是比较复杂的。第一种方式是让程序继续执行，在忽略异常的情况下完成其后续的工作。例如，如果网络包丢失，它可能会被重新发送，如果数据损坏，它可能可以从冗余备份数据中恢复。第二种方式是终止正在执行的操作，并将该异常向上传递。但是终止可能相对是比较复杂的，因为异常可能发生在一个会让系统状态不一致的地方（一个数据结构可能已经被部分初始化），异常处理代码必须能够恢复一致性，比如回退异常发生前执行的所有操作。

此外，异常处理代码为更多异常的产生提供了机会。考虑重新发送丢失的网络包的情况。可能该网络包并没有真的丢失，只是延迟了。在这种情况下，重新发送网络包会导致重复的网络包抵达对端。或者，考虑从备份冗余数据中恢复丢失数据的情况，如果此时备份冗余数据也丢失了，该怎样处理呢？在异常恢复中产生的二次异常，往往是比原始异常更加复杂且更难以察觉的。如果一个异常通过终止正常进行的操作来处理，那该终止行为也必须以另一个异常上报给它的调用者。为了防止无尽头的异常传递，开发者最终必须提供一种方式，以不会引入更多的异常方式来处理该异常。

编程语言对异常提供的支持往往是冗长且笨拙的，这使得异常处理代码变得难以阅读。例如，参考下面的代码，该代码通过 Java 提供的序列化和反序列化能力，来从文件中读取一个推文的集合。

//Code

仅仅是基本的 try-catch 样板代码，就比正常逻辑的代码多了很多行，这甚至还没有考虑最终实际处理异常的代码。这让异常处理逻辑与正常代码逻辑的关联变得非常复杂，例如，每个异常的生成点都是不明确的。一个替代的方法是将这些代码拆分为不同的 try 块，在极端情况下，每一行代码都可能会生成一个需要 try 包裹的异常。通过这样的方式，能够让异常的发生点更加清晰，但 try 块自身会拆散代码的正常处理逻辑，这又会使得代码变得更加难以阅读，此外，一些异常处理代码可能会在多个 try 块中重复。

异常处理代码的真实执行情况往往是难以确认的。一些像 I/O 错误的异常，在测试环境中难以轻易的生成。异常在系统运行过程中是偶现的，所以异常处理代码很少会被执行。由于漏洞可能很久都未被检测到，所以当一段异常处理代码最终需要执行时，很有可能无法正常运行（我最喜欢的谚语之一：“未执行的代码不起作用”）。最近的一份调查发现，分布式数据密集型系统超过 90% 的灾难性失败，都是由错误的异常处理逻辑所引起的。当异常处理代码失败时，由于其发生的频率较低，会导致难以对其进行调试。

### 10.2 过多的异常

当程序员定义更多不必要的异常时，异常处理的问题变得更加恶化了。大多数的程序员都被教导，检测并报告错误是非常重要的，他们对此经常解释为：“异常检测越多越好”。这引发了一种过度防御的风格，即任何看起来稍微可疑的点，都需要通过异常来进行抵御，这导致不必要的异常剧增，最终增加了系统的复杂度。

当我在设计 Tcl 脚本语言时，我曾犯过这样的错误。Tcl 语言包含一个可以用于移除变量的 unset 命令。当我定义 unset 命令时，该命令会在变量不存在时，抛出一个错误。在当时我认为，如果某人想要删除一个变量，而这个变量却不存在，那一定是存在一个漏洞，所以 Tcl 应该报告这个错误。但是 unset 命令最常用的一种用法之一，就是清理前序操作所创建的临时数据。通常很难预测到底创建了什么状态，特别是当操作被中途终止时。因此，最简单的方式就是清理所有之前可能已经创建过的状态。但 unset 命令的定义却让这个操作非常的笨拙：开发者们在封闭的 catch 块中对 unset 发起调用，捕获 unset 抛出异常，然后再忽略该异常。回过头来看，unset 命令的定义，是我在 Tcl 设计中犯过的最大的错误之一。

使用异常来避免处理复杂的场景是非常诱人的：与其提供一个明确的方法来解决它，不如只是通过抛出异常来将问题踢给调用者。一些人可能会反驳这种方式给予了调用者更大的权利，因为它让每个调用者都能通过不同的方式来处理异常。可是，如果连你都无法指出如何解决这种特殊的情况，那调用者很有可能更不知道该如何处理。针对一种场景生成一个异常，更像是仅仅将问题抛给其他人，同时增加了系统的复杂度。

一个类抛出的异常也是它接口的一部分，那些具有更多异常的类，通常具有更加复杂的接口，同时，它们相较于那些具有更少异常的类，也更加的浅薄。异常是接口中特别复杂的一个因素，在它被捕获之前，它可以向上传播多个堆栈层级，所以它不只会影响方法的直接调用者，也会潜在的影响上层的调用者们（和他们的接口）。

抛出一个异常是简单的，但处理它们确实很困难的。因此，异常的复杂度来自于异常的处理代码。降低异常处理带来的复杂度危害，最佳的方式是减少异常需要被处理的地点数量。本章剩余的内容，将会探讨降低异常处理器的四个技术。

### 10.3 Define errors out of existence

消除异常处理带来的复杂度的最好方式，就是让你定义的 APIs 不再抛出需要被处理的异常：定义不存在的异常。这看起来是有些亵渎的，但在实践中却是非常有效的。考虑一下上文提到的 Tcl unset 命令，当 unset 被执行以删除一个未知的变量时，与其抛出一个异常，不如不做任何其它操作，仅仅只是返回。我应当稍微修改一下 unset 的定义，相较于删除一个变量，unset 应该确认一个变量已不存在。在第一种定义中，当变量已经不存在时，unset 无法完成它需要执行的任务。但在第二种定义中，携带变量名称来调用 unset，以删除一个不存在的变量，却是非常自然的。在这种情况下，它的任务已经执行完成，所以它只需要简单的返回即可。此时不再有错误的情况需要报告。

### 10.4 示例：Windows 中的文件删除

对于错误应当如何定义，文件删除提供了另一个实例。在 Windows 操作系统中，当一个文件某个进程中被打开时，它将不允许被删除。这一直是开发者和用户感到沮丧的根源。为了删除一个正在使用中的文件，用户必须在系统中查找打开了该文件的进程，然后杀掉该进程。有时用户放弃了该操作，并重启了他们的系统，仅仅是因为这样他们才能删掉一个文件。

Unix 操作的文件删除则定义的更加优雅。在 Unix 操作系统中，如果一个被删除的文件已经被打开，Unix 不会立即删除该文件，而是会将该文件标记为删除，然后返回删除操作正常执行的结果。文件的名称已经从目录下被移除，所以其它的进程都无法再访问该文件，并且新的同名文件可以被创建，但现有文件的数据还是依然存在的。已经打开了该文件的进程，可以继续正常的对其执行读写操作。一旦所有正在访问文件的进程都关闭了访问，文件的数据就会被释放。

Unix 定义了两种不同的错误。第一种，如果文件正在被使用，则删除操作将不再会返回错误，删除操作将会返回成功，然后最终文件将会被删除。第二种，删除一个正在使用中的文件，不会对正在使用该文件的进程抛出异常。解决此问题的一种可能方法是，立即删除文件，并标记所有已打开该文件的进程，以此禁用它们的文件读写操作，任何其它尝试读写已删除文件的进程，其操作都会失败。Unix 允许它们继续正常的访问文件，延迟文件的删除而不是抛出异常。

Unix 允许进程继续读写已删除的文件，这看起来很奇怪，但我还从未遇到该机制引发重大问题的情况。相较于 Windows 定义的文件删除方式，Unix 定义的删除方式，对于开发者和用户来说更易使用。

### 10.5 示例：Java substring 方法

作为最后一个例子，来谈一下 Java 的 String 类，以及它的 substring 方法。提供一个字符串的两个索引，substring 方法将会返回一个子字符串，该子字符串从原始字符串的第一个索引字符开始，并在第二个索引字符串之前结束。但是如果任意一个索引超出了字符串的有效范围，substring 方法将会抛出一个 IndexOutOfBoundsException 异常。这个异常是不必要的，它反而复杂化了使用该方法的使用。我经常发现自己在使用该方法时，会遇到某一个索引或两个索引都不在字符串有效索引范围的情况，此时我只能提取字符串中，与指定范围重叠的所有字符。不幸的是，这需要我去检查每一个索引，并对它们向上取整到零，向下舍入到字符串的末尾。一行的方法调用，现在需要变成 5-10 行的代码。

如果 Java 的 substring 方法能够自动执行该舍入操作，该方法会变得更加易于使用，这时它将按照该 API 进行实现：“返回字符串中，索引大于或等于 beginIndex，同时小于 endIndex 的一些字符”，这样的 API 会更加简单和自然，同时它将不再需要定义 IndexOutOfBoundsException 异常。这使得方法的行为定义的更加明确，哪怕某一个索引或同时两个索引均为负值，或者 beginIndex 大于 endIndex。这样的方式在增加功能的同时，简化了方法的 API，使得方法变得更加深层。许多其它的编程语言已经采用了这种 “零错误” 的方式，例如，当请求的范围超出列表的切片时，Python 将会返回一个空字符串。

当我为不再定义异常争论时，一些人会以抛出异常将会捕获漏洞的说法来反驳我，如果错误没有被定义为异常，最终是否会导致一个充满漏洞的软件？或许这正是 Java 开发者让 substring 抛出异常的原因。错误的方式可能会捕获一些漏洞，但同时这也带来了更多的复杂性，最终产生其它的漏洞。在一个错误感知的方法中，开发者必须编写额外的代码来防止或忽略错误，但这增加了产生漏洞的可能性，或者他们可能忘记编写额外的代码，这会导致非预期的异常在运行时被抛出。正相反，定义错误不再抛出异常将会简化 APIs，并减少必须编写的代码数量。