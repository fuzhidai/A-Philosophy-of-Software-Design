第一章描述了软件开发是如何迭代和演进的，一个大型软件系统的开发，需要经过多个阶段的演进，每个阶段都会增加新的能力，并对原有的模块进行修改，这意味着软件设计是持续演进的。系统设计不可能在一开始就构思正确，成熟的系统设计，更多是由演进中的改动所决定，而非初始的构想。在前面的章节中，已经介绍过如何排除初始设计和实现中的复杂度，本章将讨论如何减缓系统演进中的复杂度增长。

### 16.1 坚持战略设计

第三章介绍了战术编程和战略编程的区别。在战术编程中，主要目标是让某些东西快速运行起来，即使最终可能带来额外的复杂度。在战略编程中，最重要的目标是产出一个优秀的系统设计。战术编程的方式很快就会带来混乱的系统设计，如果你想让系统变得更易维护和扩展，那仅仅将 “能运行” 作为标准是远远不够的，你必须优先考虑设计，并以战略思维进行思考。这个方法对于修改已有代码也是生效的。

不幸的是，当开发者进行已有代码的修改时，比如修复漏洞或增加新特性，他们通常没有进行战略性思考。战术思维是 “我如何通过最小化改动，来完成我的需求？”，一些开发者解释说，这是因为当代码被修改时，他们会感到非常的不安，担心大的改动会引入更大的风险，从而引入新的漏洞。可是这却导致了战术编程。每人引入一些小的改动，比如少量特殊情况、依赖，或者其它形式的复杂度。最终，系统设计慢慢变得越来越糟，系统演进中的每一步带来的问题都会逐渐累积。

想要维护一个具有整洁设计的系统，必须在修改已有代码时采取战略性方法。理想情况下，每次改动完成后，系统应具有你在开始改动时，脑海中就已具有的系统结构。想要达到这个目标，必须要抵抗住快速修复的诱惑。相反，思考根据所需的改动，当前的系统设计是否仍是最佳的。一旦不是，重构系统，保证系统最终的设计，仍是最佳的设计。基于这种方式，系统设计会随着每次改动提升。

这也是第 15 页中提供到的投资思维的一个例子，多投入一些额外的时间，进行系统设计的重构和优化，最终将得到一个更加整洁的系统。在加快开发的速度的同时，也会收到重构投入的回报。即使某些改动无需重构，也应该在修改代码时，留意那些可以修复的不完美设计。无论何时修改代码，都尝试寻找一些方式去提升系统的设计，至少让改进不断进行。如果没有让系统设计变得更好，那大概率就是让它变得更糟。

正如第三章中讨论的，投资思维有时会与实际的软件商业发展产生冲突。如果重构系统 “这条正确路径” 需要花费三个月的时间，但快速却肮脏的修复仅需两个小时就能完成，你可能不得不选择快速却肮脏的方式，尤其是时间紧迫时。或者，如果系统重构可能会产生不兼容情况，而影响到其他人员和团队，那重构可能是不切实际的。

尽管如此，还是应该尽可能的抵制这些诱惑。问问自己 “抛开当前的限制，为了构建一个整洁的系统，我是否已经倾尽全力？” 可能存在一些替代方案，效果几乎与三个月的重构相同，但却可以在几天内完成？或者，如果当前无力承担这样大的一次重构，可以请老板分配时间，以便让你在截止期后进行重构。每个开发组织都应该计划花费一小部分的时间，来清理和重构系统，从长远来看，这项投入会收回成本。

### 16.2 注释维护：让注释贴近代码

改动已有代码，很可能会让现存的一些注释失效。修改代码时很容易忘记更新注释，从而导致注释失真。不准确的注释会让读者感到懊恼，如果存在大量不准确的注释，读者就不再会相信注释。幸运的是，通过一些训练和指导原则，让注释保持新鲜将不再困难。本段及下面的一些段落，将提供一些具体的技巧。

确保注释及时更新，最佳的方法就是将它放置在其描述代码处，这样开发者就能在修改代码时注意到它们。注释离其关联的代码越远，它就越不太可能被及时更新。例如，方法接口注释的最佳位置，就是贴近方法体的代码文件中。任何对于方法的修改，都会涉及这段代码，因此开发者大概率会看到接口注释，并按需更新。

编写实现注释时，不要将所有的注释都放置在方法的顶端。分散开来，将其下沉到包含关联代码的最窄范围。比如，若方法具有三个主要阶段，不要将注释编写在方法的顶端，并让其描述所有阶段的内容。相反，分开编写每段注释，然后将其放置在每段首行代码的上方。另一方面，将描述整体策略的注释，放置在方法实现的顶端，可能是有益的，就像这样：

```auto
// We proceed in three phases:
// Phase 1: Find feasible candidates
// Phase 2: Assign each candidate a score
// Phase 3: Choose the best, and remove it
```

额外的细节可以编写在每段代码的上方。

总体来说，注释离其描述的代码越远，它就应该越抽象（这将减少代码变更带来的注释失效）。

### 16.3 注释属于代码，而非提交日志

代码变更时的一个常见错误，就是将变更的详细内容，存放在源代码仓库的提交信息中，而没有记录在代码中。尽管提交信息日后可从仓库日志进行浏览，但需要信息的开发者不太可能想到去仓库检索。即使检索了日志，寻找正确日志的过程也是十分乏味的。

编写提交信息时，问问自己，开发者将来是否需要使用到这些信息。如果需要，那就在代码中进行记录。举个例子，提交信息描述了一个代码变更引起的隐晦问题，假设它没有被记录在代码中，不久后开发者重回此处，可能会在没有未知的情况下，破坏之前的修复，重建了漏洞。如果想在提交信息中保留信息的备份，那也是可以的，但最重要的是要确保代码中存在该信息。这阐明了一个原则，将文档放到开发者最容易看到的地方，而提交信息不太可能是那个地方。