翻译完成时间：2024.03.15

第一次校对时间：-

第二次校对时间：-

---

一致性能够减少系统复杂度，让其行为更清晰。若系统具有一致性，则意味着相似之事行相似之法，差异之事行差异之法。一致性创造了一个认知杠杆，一旦在某个场景下学会了某件事，那就可以立即应用这些知识，以相同的方式理解不同的场景。如果系统不具有一致性，那开发者必须针对不同的场景，分别单独进行学习，这将花费更多的时间。

一致性可以减少失误。如果不具有系统一致性，两个实际不同的事物，可能会以相同的方式出现。开发者可能会就此总结出一个模式，然后基于该模式做出错误的推断。另一方面，如果系统具有一致性，那基于看起来熟悉的场景进行推断则是安全的。一致性让开发者能够以更少的失误来快速工作。

### 17.1 一致性的例子

一致性体现在系统的很多方面，下面是一些例子。

**名称：**第十四章已经讨论过使用一致性名称的好处。

**编码风格：**如今很多发展型组织都有自己的风格指南，在编译的强制规范以外，提供程序结构的约束。现代风格指南划定了一系列问题，比如缩进、括号位置、声明顺序、命名、注释，以及限制危险的语言特性。风格参考让代码更容易阅读，并能够减少某些类型的错误。

**接口：**接口包含多种实现是另一个一致性的样例。一旦你理解了接口的某个实现，那其它的实现将变得更易理解，因为你已经知道它将会提供哪些特性。

**设计模式：**设计模式是针对某些共性问题，已被广泛采纳的解决方案，例如用户接口设计中的模型-视图-控制器方案。如果采用现有的设计模式来解决问题，实现将会更加快速，更有效，对读者来说，代码将会更加清晰。设计模式的细节将在章节 19.5 中进行讨论。

**不变性：**不变性是变量或结构的一个永真属性。例如，一个存储多行文本的数据结构，可能会采取不变性的方式，强制每行都已换行字符终止。不可变性减少了在代码中需要考虑的特殊情况，并使代码更易理解。

### 17.2 后续的一致性

一致性很难维护，尤其当很多人在在同一个项目中长时间工作。某个组中的成员，可能并不了解其它组的约定。新来者可能不知晓某些规则，从而无意地打破了这些规则，并创建了一些与原有规则冲突的新规则。这里有一些建立和维护一致性的提示：

**文档：**创建一个列举了所有重要约定的文档，例如代码风格指南。将文档放到某个开发都能看到的地方，例如项目 Wiki 的明显位置。鼓励新入组的同事阅读文档，并鼓励老同事也不时回顾文档。来自不同组织的一些风格文档已经发布在网页上，可以考虑从它们开始入手。

对于更加局部的约定，例如不变性，将其放置到代码中的某个合适位置。如果没有将约定落地成文，那其他人也不太可能会遵守它们。

**实施：**即使是很好的文档，对开发者来说也难完全记住。实施这些规范最好的方式，就是编写工具来校验违反行为，并确保代码无法在未通过校验的情况下，被提交到代码库中。自动校验器对于低层语法规范尤其有效。

我近期项目中遇到了一个行终止符问题。一些开发者在 Unix 上工作，该系统的行终止由换行符实现。另一些开发者在 Windows 上工作，其行终止由换行符后的回车实现，如果开发者在某个系统上，对文件进行了一个小的修改，而该文件的上次修改是在另一个系统上完成，那编辑器有时可能会将所有的换行符适配为当前系统的格式。这造成了一个假象，仿佛该文件的所有行都被修改过，导致难以发现真正有效的改动。我们建立了一个规范，所有的文件应该只使用换行符作为行终止符，但这很难确保所有开发者使用的工具都会遵守这个规范。每次某个新的开发者加入项目，在其调整遵守规范之前，我们都会经历一场行终止符问题的洗礼。

我们最终通过编写一个简短的脚本来解决这个问题，该脚本会在改动提交到源代码仓库之前自动执行。脚本会校验所有修改过的文件，并阻止那些包含回车符的提交。并且该脚本也能手动运行，通过替换回车/换行为换行，来修复已遭破坏的文件。其快速解决了问题，并帮助训练了新的开发者。

代码审核人提供另一个强制规范的机会，并能够教育新的开发者了解这些规范。代码审核人越吹毛求疵，团队内的成员就能越快速的学会这些规范，代码也就能够更加整洁。

**入乡随俗：**最重要的一条规范，所有的开发者都应该遵循那条古老的格言 “入乡随俗”。当开始处理一个新的文件时，四周看看那些现存代码的组织形式。是否所有的公有变量和方法都在被声明在私有之前？是否所有的方法都遵循字母排序？变量采用的是 “驼峰规则”，例如 firstServerName，还是 “蛇形规则”，例如 “first_server_name”？当看到任何可能是规范的行为时，遵循它。在设计决策时，问问自己方案是否与项目中的其它方案相似，如果相似，寻找一个现存的例子，然后在代码中使用相同的方案。

不要修改已有的规范。抵御 “优化” 现有规范的欲望。存在 “更好的想法” 并不是引入不一致性的充分理由。你的新想法可能确实更好，但一致性超过不一致性的价值，通常超过一个更好方案所带来的价值。在引入不一致性的行为之前，问自己两个问题。第一，你是否具有足够充分的最新信息，来判断你的方案无法基于现有的规范来实现。第二，新方案是否足够好，以至于值得花费时间来更新所有已有规范？如果组织对这两个问题的答案是 “是”，那就去完成升级，升级完成后，旧规范应不留痕迹。可是你依然承担着风险，其它开发者可能并不知道新的规范，所以他们可能会在未来重新引入旧的规范。总而言之，重新考虑建立规范很少能高效利用开发时间。

### 17.3 走得太远

一致性不仅意味着通过同样的方式，完成相同的事情，也意味着不同的事应该以不同的方式来完成。如果过分痴迷于一致性，并尝试强制地以相同的方式，来完成不同的事，例如通过使用相同的名称来命名实际不同的事物，或者使用已有的设计模式来套用并不适合它的场景，这样将会创造复杂度和迷惑性。一致性只在开发者有信心认为 “如果它与 x 相似，那它实际就是 x” 时才会获益。

### 17.4 总结

一致性是投资思维的另一个案例。为了保证一致性，需要投入一些额外的工作：一致性决策，构建自动化校验器，在新代码中寻找相似的用途，以及在代码审核中教育团队。作为该投入的回报，你的代码将会变得更加清晰。开发者将能够更快且更准确地理解代码行为，从而工作的更高效，并降低漏洞数量。