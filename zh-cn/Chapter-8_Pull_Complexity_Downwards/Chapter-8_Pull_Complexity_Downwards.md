翻译完成时间：2024.03.30

第一次校对时间：-

第二次校对时间：-

---

本章将提供创建深层类的另一种途径。设想你正在开发一个新模块，并遇到了一些无法避免的复杂度。哪种选择更好一些：是应该让用户来处理模块的复杂度，还是应该在模块内部就将复杂度处理掉？若复杂度是由模块功能引发，那第二种选择往往是正确的那个。大部分模块的用户数量都多于开发者数量，所以最好由开发者来承担复杂度，而不是用户。作为模块的开发者，应努力简化模块用户的使用方式，即使这意味着额外工作的增加。另一种表述该想法的方式：对于一个模块来说，简单的接口比简单的实现更重要。

作为一名开发者，持有另一种对立的风格很具诱惑：解决简单问题，而将困难问题抛给其它人。如果出现了不确定如何处理的情况，那最简单的方式是抛出异常，让调用方来处理它。如果不确定要实施什么策略，那可以定义一些配置参数来控制这些策略，将其留给系统管理员，让他自己选择对其最佳的策略。

这些方法会在短时间内简化你的生活，但它们却放大了复杂度，使得很多人都必须处理该问题，而非某个人。例如，如果某个类抛出了异常，那该类的每个调用者都必须处理它。如果类暴露了配置参数，那每次安装的系统管理员，都必须学习如何设置它们。

### 8.1 示例：文本编辑器类

考虑在第六章和第七章中谈到的例子，其中有一个管理界面文本编辑器内文件文本的类。该类提供了方法将文件中的内容，从磁盘中读取到内存中，并在内存中查询和修改此文件拷贝，最后再将修改后的版本写回磁盘中。当学生实现该类时，很多人选择了面向行操作的接口设计，该接口提供的方法会读取、插入和删除文本中的整行。这使得该类的实现非常简单，但却增加高层软件的复杂度。在用户接口层，很少以整行来执行操作。例如，键盘输入会向现存行中增加单个字符，拷贝或删除的目标，可能涉及多个不同行的修改。在面向行的文本接口设计中，高层软件为了实现用户接口，将不得不拆分重组多行。

而面向字符的接口设计（如第 6.3 章节中提到的）则能够下沉复杂度。用户接口软件可以插入和删除任意范围内的文本，而无需拆分和重组多行，因此它将变得更加简单。但此时文本类的实现会变得比较复杂：如果它在内部将文本表示为行集合，那将不得不对行进行拆分和合并，以实现面向字符的操作。这种方式会更好一些，它将拆分及合并的复杂度封装在文本类内部，从而减少了系统整体的复杂度。

### 8.2 示例：配置参数

配置参数是将复杂度向上传递的一个例子。除了在内部决策某个特殊行为，类还可以暴露几个控制这些行为的参数，例如缓存大小，或放弃重试请求前的充实次数。类用户必须对这些参数提供适当的设值。现如今，配置参数在系统中非常流行，一些系统甚至有几百个参数。

支持者辩论称，配置参数很棒，它们让用户能为其特定的需求和负载，来对系统进行调整。在某些场景下，底层代码很难知道所需应用的最佳策略，然而用户却对他们的领域非常熟悉。举个例子，某个用户可能知晓某些请求比另一些更加时延敏感，所以让用户能指定这些请求的优先级，将很有意义。在像这样的场景中，配置参数能可以在更广泛的领域中，获得更好的性能。

可是，配置参数也提供了一个简单的理由，来回避处理重要问题，并将其传给其它人。在很多情况中，让用户或管理员来决定正确的参数值，是非常困难且不现实的。而在另一些情况中，正确值应该能在系统实现时，通过少量额外工作来自动决策。考虑必须处理丢包问题的网络协议。如果发送了一个请求，但却没有在确定时间周期内收到响应，它将重新发送该请求。决定重试间隔的一种方式是引入参数配置。可是，传输协议可以通过测量成功请求的响应时间，然后用其倍数作为重试间隔，以此自我计算一个合理值。该方法下沉了复杂度，使用户无需计算正确重试间隔。动态计算重试间隔，还有其他一些优点，即如果操作条件发生变化，它将能够自动进行调整。相反，配置参数则很容易失效。

因此，应该尽可能避免引入参数配置。在暴露参数配置之前，问问自己：“相较于我们的决策，用户（高层模块）是否有能力选择更好的参数值？”。当确实需要创建参数配置时，看看是否可以自动计算合理的默认值，这样用户只需在特殊情况下设置该属性。理想情况下，每个模块都应该能完整地解决问题，而参数配置则会产生不完善的解决方案，从而增加了系统的复杂度。

### 8.3 不要走的太远

在下沉复杂度时要谨慎，它很容易做过头。在极端方法中，会将整个应用程序的所有功能，都放置到一个单独的类中，这很明显是无意义的。下沉复杂度在三种情况下有效，首先下沉的复杂度与类现存功能高度相关，其次下沉能简化应用程序中其它多处的复杂性，最后下沉能够简化类的接口。记住，复杂度下沉的目的是降低系统的整体复杂度。

在第六章中，一些学生在文本类的定义里，反映了用户界面的方法，例如某个实现退格功能方法。这种方式来看起来很好，因为它下沉了复杂度。可是，增加文本类用户接口的知识，并没有简化高层代码，而且用户接口的知识与文本类的核心方法无关。在这种情况下，下沉复杂度只会导致信息泄露。

### 8.4 总结

开发模块时，找机会多承受一些额外的痛苦，以减少用户需要承受的痛苦。