作为说明本书所讨论原则的一种方式，本章回顾了过去几十年来，软件开发中流行的几种趋势和模式。对于每种趋势，将叙述它如何与本书所述原则发生关联，并使用这些原则，评估该趋势是否提供了对抗软件复杂度的杠杆。

### 19.1 面向对象编程和继承

面向对象编程是过去 30-40 年里，软件开发领域最重要的新思想之一。它引入了如类、继承、私有方法和实例变量等概念。如果谨慎使用，这些机制能够为良好的软件设计提供助力。例如，私有方法和变量用于确保信息隐藏，类外的代码无法对私有方法发起调用，也无法访问私有变量，因此它们将不会存在任何外部依赖。

继承是面向对象编程的一个关键要素。继承存在两种形式，分别会对软件复杂度产生不同影响。继承的第一种形式是接口继承，父类定义一个或多个方法的签名，但并不提供这些方法的实现。每个子类必须实现这些签名，不同的子类可以通过不同的方式来实现相同的方法。例如，某个接口可能定义了用于执行 I/O 操作的方法，某个子类可能实现了磁盘文件的 I/O 操作，而另一个子类可能对网络套接字实现了相同的操作。

通过复用相同的接口来满足不同的用途，接口继承提供了杠杆来对抗复杂度。这使得解决一个问题获取到的知识（例如如何使用 I/O 接口来读写磁盘文件），也能够用于解决其它的问题（例如通过网络套接字进行通信）。另一方面，可以从深度的角度来考虑，接口的实现越不同，那接口的深度就越深。为了让接口具有尽可能多的实现，必须抓住底层实现的本质特征，并忽略实现之间的细节差异，这个思维是抽象的核心。

实现继承是第二种形式的继承。在该形式中，父类不仅定义方法的签名，也需要定义默认实现。子类可以选择继承父类的实现，或者通过定义相同签名方法的方式，重写父类实现。没有实现继承，相同方法实现可能需要在多个子类中重复编写，使得这些子类间产生相互依赖（修改操作需要重复拷贝到多个方法中）。因此，实现继承减少了系统演进修改时代码数量，换句话说，它降低了第二章中提到的改动扩散问题。

但实现继承在父类和子类间增加了依赖。父类中的类实例变量通常会由父类和子类同时访问，这导致继承层级类之间的信息泄漏，并使得单独修改层级中的某个类变得非常困难。例如，开发者对父类的修改，可能需要检查所有的子类，以确保改动不会造成什么破坏。同样，如果子类重写父类的方法，子类的开发者可能也需要检查父类实现。最糟糕的情况下，编程者改动任何类时，需要完全了解继承层级中父类的所有下层类。实现继承的类层级广泛具有高复杂度的倾向。

因此，实现继承应谨慎使用。在使用实现继承之前，考虑基于组合的方式是否也能提供相同的效果。例如，可以使用小的辅助类实现共享功能，原始类可以通过辅助类来构建特性，而非通过继承父类的方法。

如果对于实现继承没有可行的替代方案，尝试划分父类和子类各自所管理的状态。该方式的一种实现思路是，对某个完全由父类方法管理的实例变量，子类只能通过只读的方式来访问它，或者通过父类的其它方法。通过信息隐藏的方式，减少类层级间的相互依赖。

尽管面向对象编程提供的机制致力于实现整洁设计，但其无法完全保证良好的设计。例如，如果出现浅层类，或具有复杂的接口，或对其内部状态提供额外的访问入口，最终将会导致复杂度升高。

### 19.2 敏捷开发

敏捷开发是 20 世纪 90 年代末出现的一种软件开发方法，源自一系列如何使软件开发更加轻量级、灵活、增量式的想法，并在 2001 年的实践者会议上正式定义。敏捷开发主要与软件开发过程有关（如团队组织、计划管理、单测角色、客户沟通等），而非软件设计。然而，它还是与本书所述的一些设计原则有关。

开发应当保持增量式和迭代式，是敏捷开发的重要思想。在敏捷方法中，软件系统由一系列迭代开发而成，每个迭代都会增加和评估一些新的特性，每个迭代都涉及设计、测试和客户输入。总而言之，这样的方式与本书所提倡的渐进式方法类似。正如第一章所述，在项目初期不可能设想出足够优秀的复杂系统，并以此确定最佳设计。若想最终得到良好设计，最好方式是渐进式开发系统，每次增量都增加一些新的抽象，并基于经验对已有的抽象进行重构。这与敏捷开发方式类似。

敏捷开发存在战术式编程的风险。敏捷开发倾向于聚焦特性开发，而非抽象，这会促使开发者为了尽快产出可运行的软件，而推迟设计决策。例如，一些敏捷实践者声称，你不应马上实现通用的机制，以实现一个最小特性机制开始，一旦后续发现有其它需要，再逐渐重构使其变得更加通用。尽管这些争论在一定程度上是有意义的，但违反了投资思维，并促进了战术式编程的增多。这可能会导致复杂度的快速累积。

渐进式开发通常是一个好的思路，但开发的增量应当是抽象，而非特性。最好推迟对特定抽象的所有思考，直到功能所需。而一旦需要抽象，花时间来整洁设计，并遵照第六章的建议，让其稍微通用即可。

### 19.3 单元测试

在过去，开发者很少编写测试。如果存在某些单测，也是由 QA 团队编写。但敏捷开发的一大原则，就是测试应紧密集成到开发中，编程人员应该为自己的代码编写注释。这个实践当前已经广泛传播。测试通常划分为两种类型：单元测试和系统测试。单元测试是那些通常由开发者编写的测试，它们往往小而聚焦，每个测试通常只校验某个方法中的某段代码。单元测试可以独立运行，而无需启动系统生产环境。单测通常与测试覆盖率工具一起运行，以保证应用中的每行代码都已测试。开发者无论何时编写新的代码或修改已有代码，都有责任更新单元测试，以维护适当的测试覆盖率。

第二类测试由系统测试组成（有时也被叫做集成测试），确保应用不同部分能够正确的协同工作。系统测试通常需要在生产环境中，启动整个应用。大多数情况下是有单独的 QA 或测试团队所编写。

测试，尤其是单元测试，在软件开发中扮演着非常重要的角色，因为它们推动着重构行为。缺少测试套件，会让系统主要结构的变动变得非常危险。由于没有简单的方式来探查漏洞，所以漏洞很可能直到新代码部署时才会出现，此时查找并修复漏洞的代价会非常高昂。最终，开发者会避免在缺少良好测试的情况下重构系统，同时最小化每次新增新特性或修复漏洞的代码改动，而这意味着系统的复杂度将会逐渐累积，设计错误将不会被修正。

通过一组良好的测试集，开发者在重构时会更有信心，因为测试套件会发现大多数引入漏洞。这进一步鼓励开发者进行系统结构的优化，最终产生更好的设计。单元测试尤其宝贵，相比于系统测试，它们提供了更好的代码覆盖度，所以可能发现更多的漏洞。

例如，在 Tcl 语言的开发期间，我们决定通过替换 Tcl 的翻译器为字节码编译器来优化其性能。这是一个非常大的改动，几乎会影响 Tcl 核心引擎的每个部分。幸运的是，Tcl 有着极好的单元测试套件，并且可以在新的字节码引擎上运行。现有测试在发现新引擎漏洞方面非常有效，以至于字节码编译器的 alpha 版本发布后，只发现了一个漏洞。

### 19.4 测试驱动开发

测试驱动开发是软件开发的一种方法，编程人员在编写代码前先编写单元测试。创建新类时，开发者先基于预期的行为，为该类编写单元测试。没有测试会通过，因为该类当前还没有任何代码。然后，开发者每次聚焦通过一个测试，编写足够的代码以使该测试通过。当所有测试通过，类也编写完成。

尽管我是单元测试的强力推崇者，但我并不支持测试驱动开发。问题在于，测试驱动开发聚焦于完成某个特性，而非找到最佳设计。这是纯粹而简单的战术编程，包含了其所有的缺点。测试驱动开发也太过于增量化，在任何时间点，仅靠取巧来通过特性测试，都非常具有吸引力。没有明确的时间去设计，所以最终很容易就变成一团乱麻。

正如 19.2 节提到的，开发的单元应当是抽象，而非特性。一旦发现需要抽象，就不要随着时间的推移分块进行抽象，而是一次性完成全部抽象设计（或至少足以覆盖一组相当全面的核心功能）。这才能产生整洁的设计，其各部分可以很好的组合在一起。

但在修复漏洞前先编写测试，则是有意义的。修复漏洞之前，编写因漏洞而失败的测试。然后修复漏洞，确保单测限制能够通过。这是确保漏洞被真正修复的最佳方法。如果在编写测试前修复漏洞，那新的单测可能实际并没有触发漏洞，也就无法告知你，你是否真的修复了问题。