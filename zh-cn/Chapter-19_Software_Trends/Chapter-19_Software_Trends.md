作为说明本书所讨论原则的一种方式，本章回顾了过去几十年来，软件开发中流行的几种趋势和模式。对于每种趋势，将叙述它如何与本书所述原则发生关联，并使用这些原则，评估该趋势是否提供了对抗软件复杂度的杠杆。

### 19.1 面向对象编程和继承

面向对象编程是过去 30-40 年里，软件开发领域最重要的新思想之一。它引入了如类、继承、私有方法和实例变量等概念。如果谨慎使用，这些机制能够为良好的软件设计提供助力。例如，私有方法和变量用于确保信息隐藏，类外的代码无法对私有方法发起调用，也无法访问私有变量，因此它们将不会存在任何外部依赖。

继承是面向对象编程的一个关键要素。继承存在两种形式，分别会对软件复杂度产生不同影响。继承的第一种形式是接口继承，父类定义一个或多个方法的签名，但并不提供这些方法的实现。每个子类必须实现这些签名，不同的子类可以通过不同的方式来实现相同的方法。例如，某个接口可能定义了用于执行 I/O 操作的方法，某个子类可能实现了磁盘文件的 I/O 操作，而另一个子类可能对网络套接字实现了相同的操作。

通过复用相同的接口来满足不同的用途，接口继承提供了杠杆来对抗复杂度。这使得解决一个问题获取到的知识（例如如何使用 I/O 接口来读写磁盘文件），也能够用于解决其它的问题（例如通过网络套接字进行通信）。另一方面，可以从深度的角度来考虑，接口的实现越不同，那接口的深度就越深。为了让接口具有尽可能多的实现，必须抓住底层实现的本质特征，并忽略实现之间的细节差异，这个思维是抽象的核心。

实现继承是第二种形式的继承。在该形式中，父类不仅定义方法的签名，也需要定义默认实现。子类可以选择继承父类的实现，或者通过定义相同签名方法的方式，重写父类实现。没有实现继承，相同方法实现可能需要在多个子类中重复编写，使得这些子类间产生相互依赖（修改操作需要重复拷贝到多个方法中）。因此，实现继承减少了系统演进修改时代码数量，换句话说，它降低了第二章中提到的改动扩散问题。

但实现继承在父类和子类间增加了依赖。父类中的类实例变量通常会由父类和子类同时访问，这导致继承层级类之间的信息泄漏，并使得单独修改层级中的某个类变得非常困难。例如，开发者对父类的修改，可能需要检查所有的子类，以确保改动不会造成什么破坏。同样，如果子类重写父类的方法，子类的开发者可能也需要检查父类实现。最糟糕的情况下，编程者改动任何类时，需要完全了解继承层级中父类的所有下层类。实现继承的类层级广泛具有高复杂度的倾向。

因此，实现继承应谨慎使用。在使用实现继承之前，考虑基于组合的方式是否也能提供相同的效果。例如，可以使用小的辅助类实现共享功能，原始类可以通过辅助类来构建特性，而非通过继承父类的方法。

如果对于实现继承没有可行的替代方案，尝试划分父类和子类各自所管理的状态。该方式的一种实现思路是，对某个完全由父类方法管理的实例变量，子类只能通过只读的方式来访问它，或者通过父类的其它方法。通过信息隐藏的方式，减少类层级间的相互依赖。

尽管面向对象编程提供的机制致力于实现整洁设计，但其无法完全保证良好的设计。例如，如果出现浅层类，或具有复杂的接口，或对其内部状态提供额外的访问入口，最终将会导致复杂度升高。