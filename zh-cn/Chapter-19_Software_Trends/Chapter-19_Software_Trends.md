作为说明本书所讨论原则的一种方式，本章回顾了过去几十年来，软件开发中流行的几种趋势和模式。对于每种趋势，将叙述它如何与本书所述原则发生关联，并使用这些原则，评估该趋势是否提供了对抗软件复杂度的杠杆。

### 19.1 面向对象编程和继承

面向对象编程是过去 30-40 年里，软件开发领域最重要的新思想之一。它引入了如类、继承、私有方法和实例变量等概念。如果谨慎使用，这些机制能够为良好的软件设计提供助力。例如，私有方法和变量用于确保信息隐藏，类外的代码无法对私有方法发起调用，也无法访问私有变量，因此它们将不会存在任何外部依赖。

继承是面向对象编程的一个关键要素。继承存在两种形式，分别会对软件复杂度产生不同影响。继承的第一种形式是接口继承，父类定义一个或多个方法的签名，但并不提供这些方法的实现。每个子类必须实现这些签名，不同的子类可以通过不同的方式来实现相同的方法。例如，某个接口可能定义了用于执行 I/O 操作的方法，某个子类可能实现了磁盘文件的 I/O 操作，而另一个子类可能对网络套接字实现了相同的操作。

通过复用相同的接口来满足不同的用途，接口继承提供了杠杆来对抗复杂度。这使得解决一个问题获取到的知识（例如如何使用 I/O 接口来读写磁盘文件），也能够用于解决其它的问题（例如通过网络套接字进行通信）。另一方面，可以从深度的角度来考虑，接口的实现越不同，那接口的深度就越深。为了让接口具有尽可能多的实现，必须抓住底层实现的本质特征，并忽略实现之间的细节差异，这个思维是抽象的核心。

实现继承是第二种形式的继承。在该形式中，父类不仅定义方法的签名，也需要定义默认实现。子类可以选择继承父类的实现，或者通过定义相同签名方法的方式，重写父类实现。没有实现继承，相同方法实现可能需要在多个子类中重复编写，使得这些子类间产生相互依赖（修改操作需要重复拷贝到多个方法中）。因此，实现继承减少了系统演进修改时代码数量，换句话说，它降低了第二章中提到的改动扩散问题。

但实现继承在父类和子类间增加了依赖。父类中的类实例变量通常会由父类和子类同时访问，这导致继承层级类之间的信息泄漏，并使得单独修改层级中的某个类变得非常困难。例如，开发者对父类的修改，可能需要检查所有的子类，以确保改动不会造成什么破坏。同样，如果子类重写父类的方法，子类的开发者可能也需要检查父类实现。最糟糕的情况下，编程者改动任何类时，需要完全了解继承层级中父类的所有下层类。实现继承的类层级广泛具有高复杂度的倾向。

因此，实现继承应谨慎使用。在使用实现继承之前，考虑基于组合的方式是否也能提供相同的效果。例如，可以使用小的辅助类实现共享功能，原始类可以通过辅助类来构建特性，而非通过继承父类的方法。

如果对于实现继承没有可行的替代方案，尝试划分父类和子类各自所管理的状态。该方式的一种实现思路是，对某个完全由父类方法管理的实例变量，子类只能通过只读的方式来访问它，或者通过父类的其它方法。通过信息隐藏的方式，减少类层级间的相互依赖。

尽管面向对象编程提供的机制致力于实现整洁设计，但其无法完全保证良好的设计。例如，如果出现浅层类，或具有复杂的接口，或对其内部状态提供额外的访问入口，最终将会导致复杂度升高。

### 19.2 敏捷开发

敏捷开发是 20 世纪 90 年代末出现的一种软件开发方法，源自一系列如何使软件开发更加轻量级、灵活、增量式的想法，并在 2001 年的实践者会议上正式定义。敏捷开发主要与软件开发过程有关（如团队组织、计划管理、单测角色、客户沟通等），而非软件设计。然而，它还是与本书所述的一些设计原则有关。

开发应当保持增量式和迭代式，是敏捷开发的重要思想。在敏捷方法中，软件系统由一系列迭代开发而成，每个迭代都会增加和评估一些新的特性，每个迭代都涉及设计、测试和客户输入。总而言之，这样的方式与本书所提倡的渐进式方法类似。正如第一章所述，在项目初期不可能设想出足够优秀的复杂系统，并以此确定最佳设计。若想最终得到良好设计，最好方式是渐进式开发系统，每次增量都增加一些新的抽象，并基于经验对已有的抽象进行重构。这与敏捷开发方式类似。

敏捷开发存在战术式编程的风险。敏捷开发倾向于聚焦特性开发，而非抽象，这会促使开发者为了尽快产出可运行的软件，而推迟设计决策。例如，一些敏捷实践者声称，你不应马上实现通用的机制，以实现一个最小特性机制开始，一旦后续发现有其它需要，再逐渐重构使其变得更加通用。尽管这些争论在一定程度上是有意义的，但违反了投资思维，并促进了战术式编程的增多。这可能会导致复杂度的快速累积。

渐进式开发通常是一个好的思路，但开发的增量应当是抽象，而非特性。最好推迟对特定抽象的所有思考，直到功能所需。而一旦需要抽象，花时间来整洁设计，并遵照第六章的建议，让其稍微通用即可。