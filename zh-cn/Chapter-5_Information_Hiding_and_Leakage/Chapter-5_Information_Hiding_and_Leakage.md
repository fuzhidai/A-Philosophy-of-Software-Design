在第四章中，我们说明了模块应当是深层的。本章和后续一些章节，将讨论创建深层模块的一些技术。

### 5.1 信息隐藏

信息隐藏最早由 David Parnas 提出，是实现深层模块最重要的技术。其基本思想是每个模块都应对一些知识进行封装，这些知识体现了设计上的决策。这些知识嵌入在模块的实现中，但并不出现在其接口中，因此对模块不可见。

隐藏在模块内的信息通常由一些细节组成，这些细节是关于如何实现某些功能的详细信息。下面是一些信息的示例，它们可能需要隐藏被模块内。

* 如何在 B-tree 中存储信息，以及如何高效访问它们。
* 如何识别文件内每个逻辑块对应的物理磁盘块。
* 如何实现 TCP 网络协议。
* 如何在多核处理器上调度线程。
* 如何解析 JSON 文档。

隐藏信息包括与实现机制相关的数据结构和算法。它也可以包括底层细节，例如页大小，或者包括更加抽象的顶层概念，例如对大多数文件均为小文件的假设。

信息隐藏在两个方向上降低了复杂度。首先，它简化了模块接口。使接口提供的模块功能视图，更加简单且抽象，从而隐藏了细节，降低了模块开发者的认知负载。举例来说，B-tree 类的开发者，无需关心树中节点的理想构型，也无需关心树平衡度的保持方式。其次，信息隐藏让系统演进更易进行。如果某段信息已隐藏，那除包含该信息的模块外，没有其它模块对该其存在依赖，因此关联该信息的设计改动，只会影响单个模块。例如，如果 TCP 协议变更（比如，引入新的拥塞机制），则协议实现将会需要修改，但使用 TCP 进行收发消息的高层代码却无需修改。

设计新模块时，应仔细思考哪些信息可以被隐藏在模块内。隐藏的信息越多，模块接口就越简单，模块就越深层。

注意，通过将类中的变量和方法定义为 private 来隐藏它们，并非信息隐藏。私有化元素有助于信息隐藏，因为这让元素无法从外部类直接访问。然而，隐藏于私有项的信息，仍然可以通过公有方法（如 getter 和 setter 方法）进行暴露。这种情况发生时，变量的性质和用法就像公有变量一样被公开。

全部隐藏信息于模块中，是信息以藏的最好形式，如此一来，它对于模块用户来说，将是无关且不可见的。然而，部分信息隐藏同样也有价值。比如，如果某个特性或某些信息仅为类的小部分用户所需，那可以通过单独的方法来访问，这样大部分的用户场景都不会看到它，此时就最大限度地隐藏了信息。相比于对类全部用户可见的信息，此类信息增加的依赖将会更少一些。

### 5.2 信息泄露

与信息隐藏相对的是信息泄露。若某个设计决策同时出现在了多个模块，那此时就发生了信息泄露。并在多个模块间建立了依赖，对该设计决策的任何改动，都将涉及对所有这些模块的修改。如果某段信息体现在了模块接口中，那就意味着它已经发生了泄漏，因此，更简单的接口，往往意味着更好的信息隐藏。然而，即使信息没有出现在模块接口中，也有可能会发生泄漏。假设两个类都知道某个特定文件的格式（可能其中一个类通过该格式读取文件，另一个类写入文件）。即使两个类都没有在接口中暴露该信息，它们却同时依赖了文件的格式，如果格式发生变化，那两个类将都需要进行修改。像这样的隐秘泄露比接口泄漏危害更大，因为它更加隐含。

信息泄漏是软件设计中的一大危险。作为软件设计师，你可以学到的最好技能，就是对信息泄漏的高度敏感。如果遇到类之间的信息泄漏，问问自己 “我如何重组这些类，才能使这段信息仅会影响单个类？”。如果受影响的类相对较小，并且都与泄露信息非常贴近，那可以将其合并为单个类。另一种可能可行的方式是，将信息从所有受影响的类中抽出，创建一个新的类来封装它。然而，该方法仅在可以从详细的信息中，抽象出简单的接口时才有效，如果新类的接口暴露了过多的信息，那它并没有什么作用，你只是将隐秘泄露替换为乐接口泄露。

**危险信号：信息泄露**

当多处共用相同的知识时，信息泄露就发生了，比如两个不同的类，同时知晓某个特定文件的格式。

### 5.3 顺时分解

信息泄露的一个常见诱因，是我称为顺时分解的设计风格。在顺时分解中，系统的结构对应于操作发生的顺序。考虑某个应用，它从以特定的格式读取文件，修改文件内容，然后再将其写回文件。通过顺时分解，该应用可能会划分为三个类：一个用于读取文件，另一个用于执行修改，最后一个用于写回新版内容。文件读取和文件写入的流程，都需要知道文件的格式，这就造成了信息泄漏。解决方案是，将读取和写入文件的机制，合并到一个类中。这个类将会在应用读取和写入的流程中使用。开发者很容易陷入顺时分解的陷阱，因为编写代码时，必须经常考虑操作的发生顺序。然而，大多数设计决策却是在应用生命周期内，不同的阶段出现，最终，顺时分解通常会导致信息泄漏。

顺序总是很重要，它会反映在应用程序的方方面面。可是，它不应该体现在模块结构中，除非该结构实现了信息的隐藏（也许不同的阶段，使用完全不同的信息）。在设计模块时，要关注执行每个任务所需的知识，而不是任务的发生顺序。

**危险信号：顺时分解**

在顺时分解中，执行顺序反映在了代码结构上，不同时间发生的操作，会处于不同的方法或类中。如果某个知识同时用于多个执行阶段，它就被编码到了多处，最终导致信息泄露。

### 5.4 示例：HTTP 服务器

为了说明信息隐藏中的问题，让我们考虑一下学生在软件设计课上，实现 HTTP 协议时所作出的决策。看看他们那些地方做得好，那些地方存在问题，将会很有帮助。

HTTP 是一种机制，用于 Web 浏览器和 Web 服务器的通信。当用户点击 Web 浏览器上的链接，或提交表单时，浏览器会使用 HTTP，通过网络向 Web 服务端发送请求。一旦服务端请求完处理，就会向浏览器回复响应，该响应正常会包含新的展示页面。HTTP 协议定义了请求和响应的格式，两者均以文本的形式表达。5.1 节展示了一个简单的表单提交 HTTP 请求示例。课上的同学被要求实现一个或多个类，使 Web 服务器能轻松地接收传入的 HTTP 请求，并发送响应。

图 5.1：HTTP 协议的 POST 请求，由基于 TCP 套接字发送的文本组成。每个请求包含一个初始行，一系列由空行分隔的头部，以及一个可选的请求体。初始行包含请求类型（POST 用于提交表单数据），URL 指明操作（/comments/create）及可选参数（photo_id 值为 246），和发送者使用的 HTTP 协议版本。每行头部都包括一个名称（例如 Content-Length）和紧随其后的值。对于该请求，请求体包含额外的参数（comment 和 priority）。

### 5.5 示例：太多的类

在学生所犯的错误中，将代码拆分为很多浅层类最为常见，这造成了类之间的信息泄漏。有个团队曾使用两个类来接收 HTTP 请求，第一个类从网络连接中读取请求，并将其转化为字符串，然后再由第二个类来解析该字符串。这是顺时分解的一个例子（“首先我们读取请求，然后解析它”）。由于只有解析大量的信息，才能读取 HTTP 请求，所以发生了信息泄露，举个例子，Content-Length 头记录了请求体的长度，所以必须解析该请求头，才能计算出请求的整体长度。最终，两个类都需要理解 HTTP 请求的大部分结构，解析代码也会重复出现在两类中。这种方式也为调用者增加了额外的复杂度，为了接受请求，他必须按照特定的顺序来调用不同类中的两个方法。

由于类之间共享了非常多的信息，所以将其合并为单个类可能会更好一些，该类能同时读取和解析请求。这样会提供更好的信息隐藏，因为它将请求格式的所以信息，都隔离在了单个类中，并为调用者提供了更加简单的接口（仅需调用一个方法）。

这个例子说明了软件设计中的一个通用主题：总是可以通过让单个类稍微更大些，来改善信息的隐藏。该操作的第一个原因，通过将某个特定功能相关的代码集中在一起（例如解析 HTTP 请求），生成类就包含了与该功能相关的所有内容。增加类大小的第二个原因，是提升接口层级，比如，相比于为计算的三个步骤，都提供单独的接口方法，不如提供单个方法来执行整个计算。这会让接口更加简单。这两个好处都适用于前一段的例子：将解析 HTTP 相关的代码合并到单个类中，用它的单个方法来替换那两个外部可见的方法。相较于原始类，组合后的类更深层。

当然，将大类概念执行过头也是有可能的（例如将整个应用放置在一个类中）。第九章将会讨论一些情况，在这些情况下，将代码拆分为多个小类是有效的。