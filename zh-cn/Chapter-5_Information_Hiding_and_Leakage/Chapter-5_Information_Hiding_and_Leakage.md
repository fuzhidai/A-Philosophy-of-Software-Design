翻译完成时间：2024.04.05

第一次校对时间：-

第二次校对时间：-

---

在第四章中，我们说明了模块应当是深层的。本章和后续一些章节，将讨论创建深层模块的一些技术。

### 5.1 信息隐藏

信息隐藏最早由 David Parnas 提出，是实现深层模块最重要的技术。其基本思想是每个模块都应对一些知识进行封装，这些知识体现了设计上的决策。这些知识嵌入在模块的实现中，但并不出现在其接口中，因此对模块不可见。

隐藏在模块内的信息通常由一些细节组成，这些细节是关于如何实现某些功能的详细信息。下面是一些信息的示例，它们可能需要隐藏被模块内。

* 如何在 B-tree 中存储信息，以及如何高效访问它们。
* 如何识别文件内每个逻辑块对应的物理磁盘块。
* 如何实现 TCP 网络协议。
* 如何在多核处理器上调度线程。
* 如何解析 JSON 文档。

隐藏信息包括与实现机制相关的数据结构和算法。它也可以包括底层细节，例如页大小，或者包括更加抽象的顶层概念，例如对大多数文件均为小文件的假设。

信息隐藏在两个方向上降低了复杂度。首先，它简化了模块接口。使接口提供的模块功能视图，更加简单且抽象，从而隐藏了细节，降低了模块开发者的认知负载。举例来说，B-tree 类的开发者，无需关心树中节点的理想构型，也无需关心树平衡度的保持方式。其次，信息隐藏让系统演进更易进行。如果某段信息已隐藏，那除包含该信息的模块外，没有其它模块对该其存在依赖，因此关联该信息的设计改动，只会影响单个模块。例如，如果 TCP 协议变更（比如，引入新的拥塞机制），则协议实现将会需要修改，但使用 TCP 进行收发消息的高层代码却无需修改。

设计新模块时，应仔细思考哪些信息可以被隐藏在模块内。隐藏的信息越多，模块接口就越简单，模块就越深层。

注意，通过将类中的变量和方法定义为 private 来隐藏它们，并非信息隐藏。私有化元素有助于信息隐藏，因为这让元素无法从外部类直接访问。然而，隐藏于私有项的信息，仍然可以通过公有方法（如 getter 和 setter 方法）进行暴露。这种情况发生时，变量的性质和用法就像公有变量一样被公开。

全部隐藏信息于模块中，是信息以藏的最好形式，如此一来，它对于模块用户来说，将是无关且不可见的。然而，部分信息隐藏同样也有价值。比如，如果某个特性或某些信息仅为类的小部分用户所需，那可以通过单独的方法来访问，这样大部分的用户场景都不会看到它，此时就最大限度地隐藏了信息。相比于对类全部用户可见的信息，此类信息增加的依赖将会更少一些。

### 5.2 信息泄露

与信息隐藏相对的是信息泄露。若某个设计决策同时出现在了多个模块，那此时就发生了信息泄露。并在多个模块间建立了依赖，对该设计决策的任何改动，都将涉及对所有这些模块的修改。如果某段信息体现在了模块接口中，那就意味着它已经发生了泄漏，因此，更简单的接口，往往意味着更好的信息隐藏。然而，即使信息没有出现在模块接口中，也有可能会发生泄漏。假设两个类都知道某个特定文件的格式（可能其中一个类通过该格式读取文件，另一个类写入文件）。即使两个类都没有在接口中暴露该信息，它们却同时依赖了文件的格式，如果格式发生变化，那两个类将都需要进行修改。像这样的隐秘泄露比接口泄漏危害更大，因为它更加隐含。

信息泄漏是软件设计中的一大危险。作为软件设计师，你可以学到的最好技能，就是对信息泄漏的高度敏感。如果遇到类之间的信息泄漏，问问自己 “我如何重组这些类，才能使这段信息仅会影响单个类？”。如果受影响的类相对较小，并且都与泄露信息非常贴近，那可以将其合并为单个类。另一种可能可行的方式是，将信息从所有受影响的类中抽出，创建一个新的类来封装它。然而，该方法仅在可以从详细的信息中，抽象出简单的接口时才有效，如果新类的接口暴露了过多的信息，那它并没有什么作用，你只是将隐秘泄露替换为乐接口泄露。

**危险信号：信息泄露**

当多处共用相同的知识时，信息泄露就发生了，比如两个不同的类，同时知晓某个特定文件的格式。

### 5.3 顺时分解

信息泄露的一个常见诱因，是我称为顺时分解的设计风格。在顺时分解中，系统的结构对应于操作发生的顺序。考虑某个应用，它从以特定的格式读取文件，修改文件内容，然后再将其写回文件。通过顺时分解，该应用可能会划分为三个类：一个用于读取文件，另一个用于执行修改，最后一个用于写回新版内容。文件读取和文件写入的流程，都需要知道文件的格式，这就造成了信息泄漏。解决方案是，将读取和写入文件的机制，合并到一个类中。这个类将会在应用读取和写入的流程中使用。开发者很容易陷入顺时分解的陷阱，因为编写代码时，必须经常考虑操作的发生顺序。然而，大多数设计决策却是在应用生命周期内，不同的阶段出现，最终，顺时分解通常会导致信息泄漏。

顺序总是很重要，它会反映在应用程序的方方面面。可是，它不应该体现在模块结构中，除非该结构实现了信息的隐藏（也许不同的阶段，使用完全不同的信息）。在设计模块时，要关注执行每个任务所需的知识，而不是任务的发生顺序。

**危险信号：顺时分解**

在顺时分解中，执行顺序反映在了代码结构上，不同时间发生的操作，会处于不同的方法或类中。如果某个知识同时用于多个执行阶段，它就被编码到了多处，最终导致信息泄露。

### 5.4 示例：HTTP 服务器

为了说明信息隐藏中的问题，让我们考虑一下学生在软件设计课上，实现 HTTP 协议时所作出的决策。看看他们那些地方做得好，那些地方存在问题，将会很有帮助。

HTTP 是一种机制，用于 Web 浏览器和 Web 服务器的通信。当用户点击 Web 浏览器上的链接，或提交表单时，浏览器会使用 HTTP，通过网络向 Web 服务端发送请求。一旦服务端请求完处理，就会向浏览器回复响应，该响应正常会包含新的展示页面。HTTP 协议定义了请求和响应的格式，两者均以文本的形式表达。5.1 节展示了一个简单的表单提交 HTTP 请求示例。课上的同学被要求实现一个或多个类，使 Web 服务器能轻松地接收传入的 HTTP 请求，并发送响应。

图 5.1：HTTP 协议的 POST 请求，由基于 TCP 套接字发送的文本组成。每个请求包含一个初始行，一系列由空行分隔的头部，以及一个可选的请求体。初始行包含请求类型（POST 用于提交表单数据），URL 指明操作（/comments/create）及可选参数（photo_id 值为 246），和发送者使用的 HTTP 协议版本。每行头部都包括一个名称（例如 Content-Length）和紧随其后的值。对于该请求，请求体包含额外的参数（comment 和 priority）。

### 5.5 示例：太多的类

在学生所犯的错误中，将代码拆分为很多浅层类最为常见，这造成了类之间的信息泄漏。有个团队曾使用两个类来接收 HTTP 请求，第一个类从网络连接中读取请求，并将其转化为字符串，然后再由第二个类来解析该字符串。这是顺时分解的一个例子（“首先我们读取请求，然后解析它”）。由于只有解析大量的信息，才能读取 HTTP 请求，所以发生了信息泄露，举个例子，Content-Length 头记录了请求体的长度，所以必须解析该请求头，才能计算出请求的整体长度。最终，两个类都需要理解 HTTP 请求的大部分结构，解析代码也会重复出现在两类中。这种方式也为调用者增加了额外的复杂度，为了接受请求，他必须按照特定的顺序来调用不同类中的两个方法。

由于类之间共享了非常多的信息，所以将其合并为单个类可能会更好一些，该类能同时读取和解析请求。这样会提供更好的信息隐藏，因为它将请求格式的所以信息，都隔离在了单个类中，并为调用者提供了更加简单的接口（仅需调用一个方法）。

这个例子说明了软件设计中的一个通用主题：总是可以通过让单个类稍微更大些，来改善信息的隐藏。该操作的第一个原因，通过将某个特定功能相关的代码集中在一起（例如解析 HTTP 请求），生成类就包含了与该功能相关的所有内容。增加类大小的第二个原因，是提升接口层级，比如，相比于为计算的三个步骤，都提供单独的接口方法，不如提供单个方法来执行整个计算。这会让接口更加简单。这两个好处都适用于前一段的例子：将解析 HTTP 相关的代码合并到单个类中，用它的单个方法来替换那两个外部可见的方法。相较于原始类，组合后的类更深层。

当然，将大类概念执行过头也是有可能的（例如将整个应用放置在一个类中）。第九章将会讨论一些情况，在这些情况下，将代码拆分为多个小类是有效的。

### 5.6 示例：HTTP 参数处理

服务端接收到 HTTP 请求之后，将需要访问请求中的某些信息。处理图 5.1 请求的代码，可能需要知道 photo_id 的参数值。参数可以在请求的第一行中进行指定（图 5.1 中的 photo_id），或者有时在请求体中指定（图 5.1 中的 comment 和 priority）。每个参数都有名称和值。参数值使用特殊的 URL 编码，例如，对于图 5.1 中 comment 参数值，“+” 代表空白字符，“%21” 用于替代 “！”。为了处理请求，服务端将需要这些参数中的一些值，并期望得到它们的解码形式。

大部分学生项目在参数处理方面，作出了两个很好的决策。首先，他们意识到服务端应用程序无需关心参数的位置，是在请求头中还是在请求体中，因此他们对调用方隐藏了该区别，并将两处的参数进行了合并。其次，他们隐藏了 URL 编码信息，HTTP 解析器会在将参数值返回给 Web 服务端之前，对其进行解码，所以图 5.1 中的 comment 参数值将会返回为 “What a cute baby!”，而不是 “What+a+cute+baby%21”。在这两种情况中，信息隐藏都为使用 HTTP 模块的代码，提供了更加简单的 APIs。

然而，大多数学生用于返回参数的接口都太浅，这导致失去了信息隐藏的机会。大多数项目使用 HTTPRequest 类型的实例，来持有解析后的 HTTP 请求，而 HTTPRequest 类仅有一个如下方法，用于返回参数：

```auto
public Map<String, String> getParams() {
  return this.params;
}
```

该方法返回了内部存储所有参数的 Map 引用，而不是返回单个参数。这个方法太浅，并且暴露了内部存储参数的表达形式。任何对于该表达形式的改动，都会引发接口的变动，从而需要所有调用者进行修改。修改实现时，往往涉及对关键数据模型的修改（例如提升性能）。因此，尽可能避免暴露内部数据结构，这很重要。该方法同样给调用者增加了工作量，调用者必须先调用 getParams，然后必须调用另一个方法，来从 Map 中获取的指定参数。最终，调用者必须意识到，他们不应该修改 getParams 方法返回的 Map，因为这将会影响到 HTTPRequest 的内部状态。

下面是更好一些的接口，用以获取参数值：

```auto
public String getParameter(String name) { ... }
public int getIntParameter(String name) { ... }
```

getParameter 返回字符串类型的参数值。相比于上面的 getParams 方法，它提供了更深层的接口，更重要的是，它隐藏了参数的内部表达形式。getIntParameter 将 HTTP 请求中的参数值，从字符串形式转化为整型（例如图 5.1 中的 photo_id 参数）。这节省了调用者单独进行字符串向整型的转化，并对其隐藏了该机制。用于其它数据类型的转换方法，例如 getDoubleParameter，可以按需定义。如果待获取的参数不存在，或无法转换为请求的类型，所有这些方法都会抛出异常，上面的代码省略了异常定义。

### 5.7 示例：HTTP 响应的默认值

HTTP 项目同样需要提供支持，以生成 HTTP 响应。学生的很多共性错误，都在于缺少默认值。每个 HTTP 响应都必须指定 HTTP 协议版本，有个队伍需要调用者在创建响应对象时，显示指定其版本。然而，响应版本必须与请求对象的版本相匹配，而且发送响应时，请求已经被作为参数传入（它指明了响应发送至哪里）。因此，更有效的方式，是 HTTP 类自动提供响应的版本。调用者不大可能知道需要指定的版本，如果调用者确实指定了该值，那可能会导致 HTTP 库和调用者之间的信息泄漏。HTTP 响应同样包括指定响应发送时间的 Date 响应头，HTTP 库也应为该参数提供合理的默认值。

默认值设置说明了一个原则，即接口应设计为对通用情况足够简单。它也同样是部分信息隐藏的一个例子，在正常情况下，调用者不需要意识到默认项的存在。在极少情况下，调用者需要重载默认值，因此他需要知道该值，并且可以通过调用特殊的方法来修改它。

在任何可能的情况下，类应该在无明确要求的情况下，“做正确的事”。默认值就是一个例子。第 26 页中 Java I/O 的例子，从反方向说明了该观点。文件 I/O 缓冲区是普遍需要的能力，没有人应该明确指明需要它，I/O 类应该做正确的事，默认提供该能力。最好的功能，是那些你甚至不知道其存在的功能。

**危险信号：过度暴露**

如果某个常用特性 API，强制用户学习其它很少使用的特性，而他们并不需要这些特性，那会增加这些用户的认知负载。

### 5.8 类内部的信息隐藏

本章的示例集中于信息隐藏，因为它涉及到类的外部可见 API，但信息隐藏同样可以应用于系统的其它层级，例如类的内部。尝试设计类内部的私有方法，这样每个方法都能封装一些信息和能力，并对类的其它部分进行隐藏。此外，尝试最少化每个实例变量的使用位置。有些变量可能需要在类内广泛访问，但其它变量可能只需在很少的地方访问，如果可以减少变量使用的位置，将可以消除类内部的依赖，降低它的复杂度。

### 5.9 不要走太远

只有在隐藏的信息不需要从外部访问时，信息隐藏才有意义。如果信息需要从模块外部进行访问，那一定不能隐藏它。假设模块的性能受某个特定配置参数的影响，不同使用方将需要不同的参数设置。在这种情况下，在模块接口中暴露该参数非常重要，这样它们才能被适当地调整。作为一名软件设计者，你的目标应该是最小化模块外部需要的信息，例如，如果模块可以自动调整配置，那自动调整会被暴露配置参数更好。但重要的是，意识到哪些参数是模块外部所需的，并确保它们已暴露。

### 5.10 结论

信息隐藏与深层模块是紧密相关的。如果一个模块隐藏了很多信息，那将能在减少接口的同时，提升模块提供的能力数量。这会让模块更深。相反，如果一个模块没有隐藏什么信息，要么它没有提供太多功能，要么它有一个复杂的接口，但不管哪种情况，这个模块都是浅模块。

拆分系统为多个模块时，不要受操作运行时发生时间的影响，这将会使你陷入顺时分解，最终导致信息泄露和浅层模块。相反，应考虑执行应用程序任务时，所需的不同知识片段，并设计模块来封装这些片段中的一个或多个。这将会产生简单整洁的设计，以及深层的模块。