翻译完成时间：2024.04.03

第一次校对时间：-

第二次校对时间：-

---

设计新模块时，通常会遇到一个决策，即采用哪种风格来实现它，通用风格还是以专用风格？一些人倾向于通用风格，因为这样该方案能够用于解决更大范围内问题，而不仅限于今日重要的问题。在这种情况下，新方案在未来或许可以发挥预想之外的作用，从而节省时间投入。通用方案似乎与第三章中讨论的投资思维相符，通过前期多花费一些时间，来节省后续的时间投入。

另一方面，我们知道，软件系统的未来需求很难预测，所以通用方案可能会引入永远不会需要的能力。除此之外，如果某些东西实现的太过通用，它可能无法很好解决今天面临的特定问题。结果，一些人可能会主张，最好聚焦于今日需求，只构建当前所需的东西，并根据今日的计划，来对其进行特性化处理。如果采用专用方案，并在后续发觉额外需求，那总是可以通过重构来将其通用化。专用化方案似乎与软件的增量式开发理念相符。

### 6.1 让类稍微通用

在我的经验中，以稍微通用的风格来实现新模块，一种最佳的状态。短语 “稍微通用” 是指，模块功能应反映当前需求，而其接口却不应如此。相反，接口应该足够通用，能够支持多种用途。对于当前需求来说，接口应该足够易用，但却没有专门与其绑定。词语 “有些” 很重要：不要做得太过头，构建一些太过于通用的东西，以至于很难满足当前的需求。

相比于专用方案，通用方案最大（或许是最出人意料的）的好处，是它会产出一个更简单且更深层的接口。如果在其他场景下复用该类，那通用方案同样也会节省未来的时间。不管怎样，哪怕模块只用于原始目的，出于简洁性考虑，通用方案也还是更好一些。

### 6.2 示例：存储编辑器的文本

让我们来考虑软件设计课堂上的一个例子，它要求学生构建一个简单的界面文本编辑器。编辑器需要显示文件，并允许用户通过指向、点击和键入，来编辑该文件。编辑器需要支持一个文件在不同窗口内的多个同步视图，并支持对该文件修改的多次撤销和恢复。

每个学生项目都包含某个类，用以管理文件的底层文本。文本类通常提供方法支持将文件加载到内存中，读取并修改文件中文本，然后再将修改后的文本写会到文件中。

许多学生团队为文本类实现了特性化的接口。他们知道该类会用于交互式编辑器，因此考虑了编辑器必须提供的功能，并为这些特定功能定制了文本类的接口。例如，如果编辑器的用户键入回退键，编辑器会立即删除光标左侧的字符，如果用户键入了删除键，编辑器会立即删除光标右侧的字符。知道了这些，一些团队在文本类中创建了一个方法，用来支持这些特性：

```auto
void backspace(Cursor cursor);
void delete(Cursor cursor);
```

这些方法都采用了光标位置作为它们的参数，专门的 Cursor 类型用于表示这个位置。编辑器同样需要支持选中操作，以实现拷贝和删除。学生通过定义 Selection 类，并在删除操作时，向文本类传递该类实例以

```auto
void deleteSelection(Selection selection);
```

学生可能认为，如果文本类的方法与用户可见特性保持一致，那会让用户接口的实现更加简单。实际上，并非如此，这种特性化对用户接口代码来说，收益会很小，却同时给用户接口开发者和文本类开发者，带来了很高的认知负载。文本类最终会存在大量的浅层方法，每个方法只对某一个用户接口操作有效。大量的方法，比如 delete 方法，将只会在某一处调用。最终，用户接口的开发者不得不学习大量文本类的方法。

这种方式造成了用户接口和文本类之间信息泄露。用户接口相关的抽象，例如选中或回退键，将反映在文本类中，这增加了文本类开发者的认知负载。每个新的用户接口操作，都需要一个文本类中的新方法，如此开发者在用户接口上的工作，最终也会需要在文本类中进行。类设计的目的是让每个类都能独立开发，但特性化方法却将用户接口和文本类绑在了一起。

### 6.3 更通用的 API

更好的方式是让文本类更通用一些。它的 API 应该只从基础文本特性的角度来定义，而无需反映基于其实现的高层操作。举个例子，修改文本只需要两个方法：

```auto
void insert(Position position, String newText);
void delete(Position start, Position end);
```

第一个方法在本文的任意位置，插入任意字符串，第二个方法删除位置大于等于 start，但小于 end 范围内的所有字符。这个 API 同样使用了更通用的类型 Position，而不是反映了特定用户接口的 Cursor。文本类还应提供通用的工具，来操作文本中的位置（Position），例如下面这样：

```auto
Position changePosition(Position position, int numChars);
```

这方法返回了一个新的位置，其距离给定位置（position），相隔指定的字符长度（numChars）。如果 numChars 参数为正，则新位置在文件中的位置，会处于 position 之后，而如果参数为负，则新位置在 position 之前。必要时，方法会自动跳转到下一行或前一行。有了这些方法，删除键可以通过以下代码实现（假设 cursor 变量持有当前光标位置）：

```auto
text.delete(cursor, text.changePosition(cursor, 1));
```

同样，回退键可以实现如下：

```auto
text.delete(text.changePosition(cursor, -1), cursor);
```

通过通用文本 API，实现用户接口方法的代码（例如删除和回退），会比原有使用特性化文本 API 的方式代码更多。然而，新的代码比原有代码更清晰。用户接口模块的开发者，可能更关心哪些字符需要被回退键删除。通过新代码，这非常清晰。但通过旧代码，开发者不得不跳转至文本类，然后阅读回退方法的注释来进行验证。除此之外，通用方案整体上的代码量，少于特性化方案，因为它将文本类中大量特定目的方法，替换为了更简短的通用方法。

基于通用接口实现的文本类，可能可以用于除交互编辑器外的其它需求。举个例子，设想你正在构建一个应用程序，其通过将所有特定字符串替换为另一个字符串，来对文件进行修改。特性化文本类中的方法，如 backspace 和 delete，对这个应用程序几乎无用，然而，通用文本类则已经具备了新应用程序所需的大部分能力。所缺少的只是一个方法，用来搜索给定字符串下一次出现的位置，例如这个：

```auto
Position findNext(Position start, String string);
```

当然，交互式文本编辑器可能已经具备了检索和替换的能力，在这种情况下，文本类可能已经包含了该方法。

### 6.4 通用性可以更好地隐藏信息

通用方法提供了更清晰的分界，最终产生了更好的信息隐藏。文本类无需感知用户接口的细节，例如回退键如何处理，这些细节都被封装在了用户接口类中。增加新的用户接口特性时，无需增加文本类中的辅助方法。通用接口同样将降低了认知负载：用户接口的开发者只需学习少量简单的方法，并可以复用于多种需求。

文本类中原始版本的 backspace 方法是一种错误的抽象。它意图隐藏关于删除字符的信息，但用户接口模块实际需要知道这些信息，为了确认方法的准确行为，用户接口开发者可能需要阅读 backspace 方法的实现代码。将方法放到文本类中，只是让用户接口的开发者，更难获取他们所需的信息。软件设计的重要的元素，就是确定哪些人，需要在什么时候，知道哪些事。当细节很重要时，最好使其足够清晰且明确，就像修正过的回退操作实现那样。隐藏接口背后的信息，只是增添了晦涩性。

### 6.5 问问自己

相比于创造一个整洁的通用类设计，识别该类设计会更简单一些。可以问问自己下面这些问题，它们会帮助你在通用接口和专用接口间，进行正确的权衡。

**能满足当前所有需求的最简接口是怎样的？**如果能在不削弱整体能力的情况下，减少 API 方法的数量，那已创建的方法大概率比较通用。为了删除文本，专用文本 API 包含三个方法：backspace、delete 和 deleteSelection。而更通用的 API 则只含有一个方法，并且能同时满足这三个方法的需求。只有当每个独立方法的 API 足够简单时，减少方法的数量才有意义，如果为了减少方法数量，而不得不引入额外的方法参数，那可能并没有简化任何事物。

**该方法会被用于多少场景？**如果方法仅为单个特殊场景而设计，就像 backspace 方法那样，那这是一个危险的信号，即该方法过于专用。看看是否可以将多个专用方法，替换为单个通用方法。

**API 对于当前需求是否易用？**这个问题可以帮你确定，自己是否在简化和通用化 API 上做的太过头。如果你需要编写大量的额外代码，才能使用某个为当前目的设计的类，那这同样是一个危险的信号，即接口没有提供正确的功能。例如，文本类中的某个方法，被设计成围绕单个字符进行操作：insert 插入单个字符，delete 删除单个字符。这个 API 既简单又通用。然而，它对于文本编辑器来说，可能并不是特别好用：为了完成对某范围内字符的插入和删除，高层代码需要包含很多循环。同样对于大量操作来说，单字符方法也比较低效。因此，文本类最好提供内置的支持，来满足对某范围内字符的操作需求。

### 6.6 总结

相比于专用接口，通用接口有很多优点。它们往往更加简单，并包含更少且更深层的方法。并为类之间提供了更加整洁的分隔，而反观专用方法，却往往会造成类之间的信息泄露。构造稍微通用的模块，是减少系统整体复杂度的有效方法。