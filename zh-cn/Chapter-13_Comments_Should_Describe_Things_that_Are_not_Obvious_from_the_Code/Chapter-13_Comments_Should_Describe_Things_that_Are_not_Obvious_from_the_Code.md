之所以编写注释，是因为开发者在编写代码时脑中的信息，无法通过编程语言的语句来完整地表述。注释能够记录这些信息，所以后续的开发者能够轻易地理解和修改代码。注释的指导原则是，注释应该描述那些代码中无法清晰表达的事情。

很多事情都无法从代码中清晰表述。有时可能是一些低层细节，例如，如果一对索引描述了一个范围，那索引自身所对应的元素，是否属于该范围则并不明显。有时某段代码的存在原因可能并不清晰，或为什么它由某种特殊的方式来实现。有时存在一些开发者所遵循的规则，比如 “总是在调用 b 之前调用 a”。你可能可以在查看所有代码后，猜测到规则，但这个过程痛苦且易错，注释可以让规则变得明晰。

抽象是编写注释的一大原因，注释能提供更多代码中隐含的信息，其目的是以更简单的方式来思考事物。代码过于详细，无法提取抽象信息，而注释却可以提供一种更简单，更高层次的视图，比如：“该函数被调用后，网络流量将会限制为 maxBandwidth 字节每秒”。即使某些信息能够通过阅读代码来推断得出，我们也不想强迫模块用户做这些工作，阅读代码非常耗时，并会迫使他们考虑大量与使用模块无关的信息。开发者应能在仅阅读外部可见声明的背景下，理解模块提供的抽象。而实现该目的的唯一方式，只有在定义时提供注释。

本章将探讨哪些信息需要在注释中记录，以及如何编写良好的注释。正如你所见，良好注释通常表述与代码不同层次的细节，在某些情况下更详细，而另外一些情况则更粗略（抽象）。

### 13.1 遵守规范

编写注释的第一步，需要确定注释的规范，比如注释内容和注释格式。如果编程语言具有文档编译工具，例如 Java 的 Javadoc、C++ 的 Doxygen、或 Go 的 godoc，那请遵守这些工具的规范，虽然它们都不够完美，但工具提供了足够的好处来加以弥补。如果编程语言没有可以遵守的规范，那可以尝试采用其它相似语言或相似项目的规范，这样其他开发者将会更易理解和遵守。

规范服务于两个目的。首先，确保一致性，这让注释更易阅读和理解。其次，确保你确实是在编写注释。如果对于将要注释的内容和方式没有明确想法，那最终很容易编写出毫无意义的注释。

大多数注释可以分为以下几类：

**接口：**紧邻组件（类、数据结构、方法和函数）声明前的注释块，描述组件接口。对于某类，注释描述该类提供的整体抽象。对于某方法或函数，注释描述它的整体行为、参数和返回值，还可能包括副作用、抛出异常，以及调用方在调用前必须知晓的其它信息。

**数据结构成员：**紧邻数据结构字段定义的注释，例如实例变量或类静态变量。

**实现注释：**方法或函数内部的注释，描述代码内部的工作方式。

**跨组件注释：**描述跨组件边界依赖的注释。

前面两个类型的注释最为重要。所有类和方法都应具有接口注释，每个类变量也应具有注释。有时变量或方法的声明非常清晰，以至于无需增加注释，getter 和 setter 方法有时就是这类情况，但这种情况很少见，相比于花精力担心是否需要注释，注释所有内容则容易得多。实现（Implementation）注释通常是多余的（见下面的 13.6 节）。跨组件注释最为最少见，并且最难编写，但当需要它们时，它们往往又是比较重要的，13.7 节将详细探讨它们。

### 13.2 不要复述代码

不幸的是，许多注释并不是特别有用。最常见的原因是注释复述了代码，注释中的所有信息，都能够轻易的从注释紧邻的代码中推断出来。下面是近期某篇研究论文中出现的代码示例：

```auto
ptr_copy = get_copy(obj)             # 获取指针拷贝
if is_unlocked(ptr_copy):            # obj 是否没有锁？
  return obj                         # 返回当前 obj
if is_copy(ptr_copy):                # 是否为拷贝?
  return obj                         # 返回 obj
thread_id = get_thread_id(ptr_copy)
if thread_id == ctx.thread_id:       # 被当前 ctx 锁定
  return ptr_copy                    # 返回拷贝
```

除了 “被锁定” 注释以外，这些注释中没有任何有效信息，来提供某些关于线程的信息，无法从代码直接获得。可以发现，这些注释与代码的详细程度大致相同，每行代码都有一个注释，用以描述这行代码。类似这样的注释毫无用处。

这里是更多重复代码的注释样例：

```auto
// 增加一个水平滚动条
hScrollBar = new JScrollBar(JScrollBar.HORIZONTAL);
add(hScrollBar, BorderLayout.SOUTH);

// 增加一个竖直滚动条
vScrollBar = new JScrollBar(JScrollBar.VERTICAL);
add(vScrollBar, BorderLayout.EAST);

// 初始化插入符号位置的相关值
caretX = 0;
caretY = 0;
caretMemX = null;
```

这些注释没有提供任何价值。对于起始的两行注释，代码已经足够清晰，不再需要注释。在第三个情况下，注释可能有用，但当前注释没有提供足够有帮助的细节。

编写完注释后，询问自己下面这个问题：如果某人从未看过这些代码，他是否仅通过查看与注释相邻的代码，就可以编写出这些注释？如果答案是可以，那就像上面的示例一样，这些注释并没有让代码更易理解。像这样的注释，正是有些人认为注释毫无价值的原因。

另一个常见错误，是在注释中使用某些词语，而这些词语已在被注释实体名称中使用。

```auto
/*
* Obtain a normalized resource name from REQ.
*/
private static String[] getNormalizedResourceNames(HTTPRequest req) ...

/*
* Downcast PARAMETER to TYPE.
*/
private static Object downCastParameter(String parameter, String type)
...

/*
* The horizontal padding of each line in the text.
*/
private static final int textHorizontalPadding = 4;
```

这些注释只是将方法名或变量名中的单词提取出来，可能再增加一些参数名称和参数类型，并最终将它们拼成一个句子。例如，在第二个注释里，唯一未在代码中出现的词是 “to”。同样，只需查看声明，就可以完成这些注释的编写，而无需理解变量的含义，因此它们毫无价值。

**危险信号：注释复述代码**

如果注释中的信息，已经可以从相邻代码中明确获得，那这些注释就是无效的。如果注释使用了组成被描述事物名称的单词，那就是这种情况的一个例子。

同时，这些注释也遗漏了一些重要的信息，例如，什么是 “标准化的资源名称”，getNormalizedResourceNames 方法返回数组中的元素是什么？内边距的单位是什么？内边距是在每行的一侧还是两侧？在注释中记录这些信息，将会更有帮助。

编写良好注释的第一步，就是使用那些未在被描述实体名称中出现的词语。为注释选择能够提供有关实体含义额外信息的词语，而非仅仅重复其名称。例如，这是 textHorizontalPadding 方法优化后的注释：

```auto
/*
* The amount of blank space to leave on the left and
* right sides of each line of text, in pixels.
*/
private static final int textHorizontalPadding = 4;
```

这个注释提供了无法从声明本身直接获取的额外信息，例如单位（像素），以及内边距实际是对每行的两侧都生效。相比于直接使用术语 “内边距”，该注释解释了内边距是什么，以防读者不了解该术语。

### 13.3 低层注释提升准确度

现在已经知道了不应该做什么，接下来让我们讨论注释中应该提供哪些信息。注释通过提供与代码不同层次的细节来扩充代码。相比于代码，有些注释提供更低层、更细节的信息，通过明晰代码的准确含义，来提升准确度。另一些注释则提供更高层、更抽象的信息，以提供直观性，例如代码背后的推理，或通过更简单抽象的方式来思考代码。而与代码处于相同层级的注释，则更像是对代码的复述。本节会讨论更多低层方法的细节，下一节会讨论高层方法。

在注释变量（例如类实例变量、方法参数和返回值）时，准确度是最有用的。变量声明的名称和类型通常不够准确，注释可以补充这些缺失的细节，例如：

* 这个变量的单位是什么？
* 边界条件是开放还是关闭？
* 如果允许一个空值，它意味着什么？
* 如果变量引用一个最终必须被释放或关闭的资源，谁负责执行该操作？
* 变量（不变的）是否存在某些属性总是为真，比如 “这个列表总是至少包含一个条目”？

有些信息可以通过阅读使用该变量的代码获取，但这非常耗时且易错，声明的注释应足够清晰和完整，无需上述这些操作。当我说注释应描述代码未清晰表达的事情时，其中的 “代码” 是指紧邻注释（声明）的代码，而非 “应用的所有代码”。

注释过于含糊是变量注释的常见问题。这里有两个注释不够准确的样例：

```auto
// 响应缓冲区中的当前偏移量
uint32_t offset;

// 包含文档内的所有行宽和现实次数
private TreeMap<Integer, Integer> lineWidths;
```

第一个例子中，“当前” 意味着什么并不清楚。第二个例子中，TreeMap 的键是行宽，值是其出现的次数，而这些信息并不够清楚。同样，宽度是以像素衡量还是以字符衡量？下面修正后的注释提供了额外的细节：

```auto
// 未返回给客户端的首个对象，在此缓冲区中的位置
uint32_t offset;

// 持有关于行长度的数据，其格式为 <长度，数量>，
// 长度是一行中字符串的数量（包括换行符），
// 数量是包含相同数量字符的行数。
// 如果没有特定长度的行，则没有该长度的条目。
private TreeMap<Integer, Integer> numLinesWithLength;
```

第二个声明使用更长的命名来传达更多信息，并将单词 “width” 改为 “length”，这更容易让人认为值的单位是字符而非像素。需要注意的是，第二个注释不只记录了每个条目的细节，也记录了条目缺失的含义。

在注释变量时，考虑使用名词，而非动词。换句话说，关注变量代表什么，而非如何操作。考虑下面这个注释：

```auto
/* 跟随者变量: 指示器变量，让接收器和周期任务线程能够通讯，
 * 以确认心跳是否在跟随者的选举超时时间窗口内被接收到。
 * 接收到有效心跳时，切换到 TRUE
 * 选举超时时间窗重置时，切换到 FALSE
 */
private boolean receivedValidHeartbeat
```

该注释描述了如何通过类中的几段代码修改变量，如果它能描述变量代表什么，而非只是反映代码结构，那它将更加简短有效。

```auto
/* True 意味着在上次选举计时器重置后，已经接收到心跳。
 * 用于在接收器和周期任务间通讯。
 */
private boolean receivedValidHeartbeat;
```

通过这个注释，很容易就可以推断出，接收到心跳时，该变量一定会被设置为 true，而选举计时器重置后，该值将置为 false。

### 13.4 高层注释增强直觉

提供直觉是注释增强代码的第二种方式。相比于代码，这些注释在更高的层次上编写，省略了细节，以帮助读者理解整体的意图和代码的结构。通常用于方法的内部注释，以及接口注释。例如，考虑下面这些代码：

```auto
// 如果有一个 LOADING 状态的 readRpc，
// 使用与 assignPos 指向的 PKHash 相同的会话，
// 并且该 readRpc 中的最后一个 PKHash 小于当前分配的 PKHash，
// 那我们将分配 PKHash 放入该 readRpc 中。
int readActiveRpcId = RPC_ID_NOT_ASSIGNED;
  for (int i = 0; i < NUM_READ_RPC; i++) {
    if (session == readRpc[i].session
          && readRpc[i].status == LOADING
          && readRpc[i].maxPos < assignPos
          && readRpc[i].numHashes < MAX_PKHASHES_PERRPC) {
      readActiveRpcId = i;
      break;
  }
}
```

这里的注释过于低层和详细。一方面，它部分复述了代码 “如果这里存在 readRPC 的状态为 LOADING”，只是复述了判断 readRpc[i].status == LOADING。另一方面，该注释没有解释代码的整体意图，以及代码在方法中的作用。因此，它并不能帮助读者理解代码。

更好一些的注释：

```auto
// 尝试将当前密钥哈希，附加到尚未发送至所需服务器的现有 RPC 中
```

该注释没有包含任何细节，相反，它从更高层次上描述代码的整体功能。有了这些高层次信息，读者几乎可以解释代码发生的所有事情：循环必须遍历所有现存的远程过程调用（RPCs），session 判断可能用于确认特定 RPC 是否被指派给了正确的服务端，LOADING 判断表明 RPCs 可以很多状态，在某些状态下，添加很多哈希并不安全，MAX - PKHASHES_PERRPC 判断表明对于单个 RPC 可以发送多少个哈希，存在一定的限制。唯一无法通过注释解释的，就是 maxPos 判断。此外，新注释为读者评判代码提供了基础：代码是否执行了将密钥哈希添加到现有 RPC 时，需要完成的所有操作？原始注释没有描述代码的整体意图，所以读者很难确定代码的行为是否正确。

高层注释比低层注释更难编写，因为你必须以不同的方式来思考代码。问问自己：这段代码想要做什么？表述代码所有信息的最简方式是什么？这段代码最重要的是什么？

工程师往往非常注重细节，我们热爱细节，并善于管理大量细节，这也是成为一名优秀工程师的必要条件。但优秀的软件设计师也应能跳出细节，从更高的层次思考系统。这意味着需要确定系统最重要的方面，忽略底层细节，只考虑系统最基本的特征，这是抽象的本质（找到简单的方式来考虑复杂的实体），也是编写高层次注释的必要行为。良好的高层次注释，表述一个或几个提供概念框架的简单想法，例如 “附加到现有 RPC 中”。有了框架，就很容看出特定的代码语句，如何与整体的目标相关联。

这是另一个代码样例，具有良好的高层次注释：

```auto
if (numProcessedPKHashes < readRpc[i].numHashes) { 
  // 某些密钥哈希可能无法在该请求中被找到
  // （可能因为它们没有存储在服务器上，或服务崩溃，
  // 或响应消息中没有足够的空间）。
  // 标记未被加工的哈希值，这样它们能够在新的 RPCs 中被重新分配。
  for (size_t p = removePos; p < insertPos; p++) {
    if (activeRpcId[p] == i) {
      if (numProcessedPKHashes > 0) {
        numProcessedPKHashes--;
      } else {
        if (p < assignPos)
          assignPos = p;
        activeRpcId[p] = RPC_ID_NOT_ASSIGNED;
      }
    }
  }
}
```

这段注释做了两件事，第二句提供了代码功能的抽象描述，第一句则有些不同：它解释（从高层）了为什么代码会被执行。“我们是如何走到这一步的” 形式的注释，对于帮助读者理解代码非常有效。例如，注释方法时，描述最有可能调用该方法的条件，将会非常有用（尤其如果代码只在特殊的场景下被调用）。