翻译完成时间：2024.03.09

第一次校对时间：-

第二次校对时间：-

---

 为变量、方法和其它实体的选择名称，是软件设计中最被低估的方面之一。好的名称是另一种形式的文档，它们让代码变得更易阅读，减少对其它文档的需要，并让发现错误变得更加容易。相反的，糟糕的名称选择，会增加代码的复杂度，使代码变得具有歧义，容易产生错误的理解，最终导致漏洞的产生。名称选择是复杂度递增原则的一个例子，为一个特殊的变量挑选一个平庸的名称，而非最合适的名字，可能不会对系统的整体复杂度产生影响。但是，软件系统包含上千个变量，为所有这些变量选择一个合适的名称，会对系统的复杂度和可维护性带来很大的影响。

### 14.1 示例：引发漏洞的错误名称

有时，即使只是一个变量命名不当，都有可能会产生严重的后果。我曾经修复过的一个最具有挑战性的漏洞，正是源于一个糟糕的命名选择。在八十年代末期，九十年代初期，我和我的毕业生共同开发了一个叫做 Sprite 的分布式操作系统。我们发现有时文件会突然丢失数据，某个数据块会突然被清零，哪怕这个文件从来没有被用户修改过。因为这个问题并非经常发生，因此很难对它进行排查。一些毕业生尝试去找到漏洞，但他们并没有取得任何进展，最终不得不放弃。然而，我认为任何未解决的漏洞，都是无法容忍的个人侮辱，所以我决定继续排查它。

虽然花费了六个月的时间，但最终我还是找到并修复了这个漏洞。问题其实非常的简单（对于大多数漏洞来说，一旦你解决了它们）。文件系统的代码在两个不同的用途下，使用了 block 这个变量。在一些场景中，block 指代磁盘上的物理块数量，而在另一些场景中，block 指代文件内部的逻辑块数量。不幸的是，在一处代码中，block 变量原本用来存储逻辑块的数量，但它意外的被用在了另一个需要物理块数量的上下文中，最终一个磁盘上一个无关的块被覆写为了零。

在排查问题的过程中，不同的人包括我自己，都阅读过这部分有问题的代码，但我们都从来没有注意到这个问题。当我们看到一个名称为 block 的变量，被用于表示物理块的数量时，我们反射式的假设，它真的持有物理块的数量。经过漫长的测试过程，最终表明问题一定出在特定的语句中，然后我才能克服名称带来的心理障碍，并检查其值的确切来源。如果不同的变量名称，被用在不同的类型块上，比如 fileBlock 和 diskBlock，这个错误就不太可能会发生，因为编程者能够知道 fileBlock 不会被用在其它的场景中。

不幸的是，大多数的开发者不会花费很多的时间，来考虑他们命名。他们倾向于使用脑海中出现的第一个名称，只要它与其所命名的事物足够接近。例如，block 足够接近磁盘上的物理块，以及文件中的物理块，它确实不是一个非常糟糕的名称。即使如此，它最终还是导致花费大量的时间，去排查一个不易察觉的漏洞。因此，你不应该满足于采用 “相当接近” 的命名。多花费一些额外的时间，去选择一个更好的名称，它准确、清晰且易懂。额外的投入很快就会得到回报，最终你将学会如何去快速的选择一个好的名称。

### 14.2 绘制一幅图像

选择名称时，命名者的目标是在读者的脑海中，塑造有关所命名事物本质的形象。一个好的名称，传达了很多关于事物底层是什么的含义，以及同样重要的，它不是什么。当考虑某个特定的名称时，问问你自己：“如果有人仅仅看到了该名称，而没有看到任何关于它的说明、文档，以及任何使用该名称的代码，他们能够在多大程度上，猜测到这个名称所指代的事物？是否还有其它的名称，能够绘制一幅更加清晰的图像？”。当然，单独一个名称能够表达的信息是非常有限的，当其具有超过两三个单词后，它就会变得非常笨重。因此，挑战在于如何仅通过几个的单词，来承载更多关于实体的重要信息。

名称是抽象的一种形式，它提供了一种足够简单的方式，来对复杂的基础实体进行思考。与其他形式的抽象类似，最佳的名称能够聚焦于基础实体最重要的部分，同时忽略那些不太重要的细节部分。

### 14.3 名称应当是精确的

好的名称有两个特性：精确和一致。让我们从精确这个特性开始。过于宽泛和模糊，是命名时最常见的问题，这让读者很难确定名称具体指代的事物，并可能会假设该名称指代与其真实含义不同的事物，例如上面漏洞中的 block。考虑下面这个方法的定义：

```auto
/**       
 * 返回当前对象正在管理的小索引总量。       
 */      
int IndexletManager::getCount() {...}
```

单词 “count” 太过于宽泛，什么的数量？如果有人看到这个方法的调用，他们不太可能知道这个方法的作用，除非阅读方法的文档。更精确的名称，比如 getActiveIndexlets 或 numIndexlets 会更好一些，通过采用这两个名称之间的任何一个，读者将更有可能在无需阅读文档的情况下，猜出方法返回的内容。

下面是其它的一些例子，它们来源于不同的学生项目，其中的命名都不够精确：

* 在一个构建文字编辑器的 GUI 项目中，使用 x 和 y 来指代一个字符在文件中的位置。这两个名称太过于宽泛，它们可能具有很多含义，比如，它们可能同样代表字符在屏幕中的坐标。有些人在单独看到名称 x 时，不太可能认为其指代字符在一行文字中的位置。如果使用例如 charIndex 或 lineIndex 这样的命名，代码将变得更加清晰，因为它体现了代码实现的具体抽象。
* 另一个编辑器的项目包含了如下代码：

```auto
// Blink state: true when cursor visible.      
private boolean blinkStatus = true;
```

名称 “blinkStatus” 没有传达足够的信息。单词 “status” 对于一个布尔类型的值来说，太过于模糊：它没有提供任何关于对与错含义的线索。单词 “blink” 也很模糊，因为它没有说明是什么正在闪烁。下面的替换方案或更好一些：

```auto
// 控制指针闪烁: true 代表指针是可见的，      
// false 代表指针是不可见的。      
private boolean cursorVisible = true;
```

名称 cursorVisible 传达了更多的信息，例如，它让读者能够猜测到 true 值的含义（按照通常规则，布尔变量的名称应始终是谓词）。单词 “blink” 从名称中消失，所以当读者想要知道为什么指针并非总是可见时，他们将可以求助于文档，这个信息并非那么重要。

* 一个实现了共识协议的项目，包含如下代码：

```auto
// 该值代表当前服务器在本轮选举中，未投票给任何它者      
private static final String VOTED_FOR_SENTINEL_VALUE = "null";
```

这个值的名称表明它很特殊，但没有说明特殊的含义是什么。一个更加具体的名称，如 NOT_YET_VOTED 会更好一些。

* 在没有返回值的方法中，使用了名为 result 的变量。这个名称存在很多的问题。首先，它会造成一种误导性的印象，即它将是该方法的返回值。其次，它基本不提供任何关于它实际保存的内容信息，除了它是一些计算值。名称应该提供有关结果是什么的信息，比如 mergedLine 或 totalChars。在那些确实具有返回值的方法中，使用 result 名称是合理的。虽然这个名称还是有一些宽泛，但读者可以通过阅读方法文档的方式，来了解其含义，并知道该值最终将作为返回值，这是非常有帮助的。

危险信号：模糊的名称

如果变量或方法的名称非常宽泛，以至于可以指代很多不同的事物，那它不会给开发者传递太多的信息，并使得基础实体更有可能会被误用。

与其它的规则相同，这条关于选择精确名称的规则，也有一些例外的情况。比如，使用宽泛的 i 和 j 来命名迭代器变量，是可以接受的，只要循环只涉及几行代码。如果你可以看到一个变量全部的使用范围，那变量的含义从代码来看就已经非常明显，因此你不需要一个很长的名称，例如，考虑以下代码：

```auto
for (i = 0; i < numLines; i++) {         
  ...
}
```

从这段代码可以清楚地看出，i 用于迭代某个实体中的每一行。如果循环太长，以至于你无法一次看到所有的内容，或者如果迭代变量的含义很难从代码中弄清楚，那就需要使用更具描述性的名称。

名称也可能过于特化，比如对于这个删除一个范围内文本的方法定义：

```auto
void delete(Range selection) {...}
```

参数名称 selection 过于特化，因为它表明被删除的文本，总是用户界面中被选中的文本。然而，这个方法可以在任何范围的本文上调用，无论是否选中。因此，参数的名称应该更加泛化一些，例如 range。

如果你发现难以为某个特定的变量，想出一个准确、直观且简短的命名，这是一个危险的信号。它表明这个变量的定义或意图可能是模糊不清的。发生这种情况时，可以考虑进行替换分解。例如，你可能正在尝试用一个单独的变量，去代表多个事物，如果是这样，将表象拆分为多个变量，使得每个变量的定义更加简单。选择好名称的过程，可以通过识别弱点来改进你的设计。

危险信号：难以选择名称

如果难以为某个变量或方法找到一个简单的名称，来绘制一个清晰的基础实体图像，那可能暗示着基础实体也没有一个清晰的设计。

### 14.4 一致地使用名称

好名称的第二个特性是一致性。在任何的程序中，有些变量是被反复使用的，例如，一个文件系统需要反复操作块的数量。对于每种常见的用法，为其选择一个能表达意图的名称，并在各处使用相同的名称。比如，一个文件系统可能通常需要使用 fileBlock，来存储文件中的块索引。与重用公共类相似，一致的命名能够降低认知负载，一旦读者在一个上下文中看到过该命名，他们就可以重用该知识，并在不同上下文中看到该名称时，立即做出假设。

一致性存在三个要求：首先，对于同样的目的，总是采用相同的名称。其次，切勿将通用名称，用于其制定目的外的任何用途。最后，确保命名的用途足够的窄，使得所有使用该命名的变量，都具有相同的行为。最后的一个要求，在本章开篇的文件系统漏洞中被违反，文件系统采用 block 来命名两种不同用途的变量（文件块和磁盘块），导致读者对变量的含义产生了错误的假设，最终引发了系统的漏洞。

有时你需要多个不同的变量，来指代一个相同类别的事物。比如，一个拷贝文件数据的方法，将需要获取两个块的数量，一个是源块数量，另一个是目标块数量。发生这种情况时，为每个变量选择通用的命名，但需要为其添加有区分的前缀，例如 srcFileBlock 和 dstFileBlock。

循环是一致命名可以提供帮助的另一个场景。如果你使用名称 i 和 j 来命名循环变量，应该总是在最外层循环使用 i，而在最内层使用 j。这让读者在看到给定的名称时，能够快速（安全地）推断出代码的行为。

### 14.5 不同的观点：Go 风格指南

并非所有人都赞同我对命名的观点。一些 Go 语言的开发者主张命名应该非常短小，通常只包含一个字符。在关于 Go 语言名称选择的报告中，Andrew Gerrand 认为 “长命名模糊了代码的行为”，他展示了如下的代码示例，在该示例中采用了单字母的变量命名：

```auto
func RuneCount(b []byte) int {
  i, n := 0, 0
  for i < len(b) {
    if b[i] < RuneSelf {
      i++
    } else {
      _, size := DecodeRune(b[i:])
      i += size
    }
    n++
  }
  return n
}
```

并主张这样的命名方式，比下面采用长命名的版本可读性更高：

```auto
func RuneCount(buffer []byte) int {
  index, count := 0, 0
  for index < len(buffer) {
    if buffer[index] < RuneSelf {
      index++
    } else {
      _, size := DecodeRune(buffer[index:])
      index += size
    }
    count++
  }
  return count
}
```

就我个人来说，我并没有发现第二个版本比第一个版本更难阅读。如果说有什么不同的话，那就是名称 count 相较于名称 n，为变量的行为提供了更多一些的线索。在一个版本中，我通篇阅读代码，尝试找到变量 n 的含义，但我在第二个版本中却不需要这样做。但是如果名称 n 在整个系统中，一致且一直地被用来指代计数（没有任何其它含义），那简短的名称，对于开发者来说可能会更加清晰。

Go 文化鼓励对于多种不同的事物，采用相同的简短名称，ch 代表字符或通道，d 代表数据，区别或距离等等。但对我来说，像这些具有歧义的名称，最终可能会导致混淆和错误，正如在 block 示例中所看到的。

总结来说，我主张可读性应该由读者来决定，而非编写者。如果你编写具有短名称变量的代码，同时阅读它的人认为它很容易理解，那它就是没有问题的。而如果你开始因为代码的模糊而受到控诉，那你就应该考虑使用更长的名称（在网上搜索 “Go 语言短名称”，就会发现这样的一些控诉）。同样的，如果因为长名称变量导致代码难以阅读，而收到控诉，你也应该考虑使用更短的一些名称。

我非常赞同 Gerrand 的一个评论：“名称的声明与其使用之间的距离越远，名称就应该越长”。前面关于使用 i 和 j 命名循环变量的讨论，正是此规则的一个例子。

### 14.6 总结

好的名称选择，让代码变得更加清晰，当有人第一次看到某个变量时，他们在没有其它想法的情况下，首次做出的猜测就是准去的。选择一个好的名称，是第三章讨论的投资观念的一个例子。如果你在选择一个好的名称之前，稍微多花费一些额外的时间，它将会使你后续在该段代码上的工作，变得更加简单。此外，你将不太可能引入漏洞。发展命名的技巧，同样是一份投资。当你第一次决定不再满足于平庸的名称时，你可能会发现，想出一个好的名称，是非常令人沮丧和耗时的过程。可是，当你具备了更多的经验后，你会发现它变得越来越简单。最终，你将几乎不需要花费额外的时间，去构想好的名称，因此你可以毫无成本的享受它带来的好处。